/* This code may be used on both X and Miscrosoft Windows. */

#include <stdio.h>
#include <stdlib.h> 
#include <math.h>
#ifdef _WINDOWS
#  include "resource.h"
#  pragma warning( disable : 4244 )
#  pragma warning( disable : 4996 )    /* Allow cross-platform sscanf() */
#endif

#include "GlgApi.h"

#define fmin( a, b )     ( (a) < (b) ? (a) : (b) )

/* Set this defined constant to be 1 to use code generated by the
 * GLG Code Generation Utility.
 */
#define USE_GENERATED_CODE     0

#if USE_GENERATED_CODE
/* The following symbols should be defined in the file generated by the
 * GLG Code Generation Utility.
 */
extern long DemoData[];
extern long DemoDataSize;
#endif

/* Some constants defining simulation parameters. */
#define MAX_NUM_PLANES    2000   /* Max plane array size in the demo. */
#define MAX_DISTANCE       0.8   /* Max allowed distance from the center,
                                    in relative units. */
#define DESTROY_DISTANCE  0.03   /* How close a missile needs to get to a plane 
                                    to destroy it (relative units). */
#define CHANGE_THRESHOLD  0.99   /* The number in the range [0;1]; defines 
				  * how often planes change direction. */
#define PLANE_SPEED       0.01   /* Plane's speed */
#define MISSILE_SPEED      0.6   /* Initial speed relatively to the plane */
#define TRANSITION_NUM      40   /* The number of steps required for a turn */
#define DELAY                2   /* Delay after a turn */
#define MISSILE_DELAY       10   /* Missile adjustment delay */

#define UPDATE_INTERVAL     40   /* Update interval in msec */

#define DEBUG_TIMER          0   /* Set to 1 to debug timer intervals */

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950
#endif

/* Macros to convert between degrees and radians. */
#define RAD( angle )      ( angle / 180. * M_PI )
#define DEG( angle )      ( angle * 180. / M_PI )

struct Planes
{
   GlgObject plane;
   double speed;
   GlgPoint position;
   GlgPoint direction;
   GlgPoint direction_change;
   GlgLong change_state;
   GlgLong correcting_distance;  /* Prevents from changing direction for some 
                                    time after a turn to let a plane correct 
                                    the distance from the center. */
   GlgBoolean destroyed;
   GlgLong missile_delay;
} PlaneArray [ MAX_NUM_PLANES ];

/* Macros for accessing elements of the simulation structure. */
#define Plane( i )                PlaneArray[ i ].plane  
#define PlaneSpeed( i )           PlaneArray[ i ].speed
#define PlanePosition( i )        PlaneArray[ i ].position
#define PlaneX( i )               PlaneArray[ i ].position.x  
#define PlaneY( i )               PlaneArray[ i ].position.y
#define PlaneZ( i )               PlaneArray[ i ].position.z
#define PlaneDirection( i )       PlaneArray[ i ].direction
#define PlaneAngleX( i )          PlaneArray[ i ].direction.x  
#define PlaneAngleY( i )          PlaneArray[ i ].direction.y
#define PlaneAngleZ( i )          PlaneArray[ i ].direction.z
#define PlaneAngleXChange( i )    PlaneArray[ i ].direction_change.x  
#define PlaneAngleYChange( i )    PlaneArray[ i ].direction_change.y
#define PlaneAngleZChange( i )    PlaneArray[ i ].direction_change.z
#define PlaneChangeState( i )     PlaneArray[ i ].change_state
#define PlaneCorrectingDistance( i )  PlaneArray[ i ].correcting_distance
#define PlaneDestroyed( i )       PlaneArray[ i ].destroyed
#define PlaneMissileDelay( i )    PlaneArray[ i ].missile_delay

/* Planes with odd indices are missiles. */ 
#define IS_MISSILE( plane )  ( plane % 2 )
#define IS_PLANE( plane )    ( ! IS_MISSILE( plane ) )

/* Some global simulation objects and variables. */
GlgObject
   TopViewport,
   MapViewport,
   InfoDialog,
   GISObject,
   Plane3DFull,         /* More elaborate 3D icon */
   Plane3DLight,        /* A simpler icon used with large number of planes. */
   Plane2D,             /* The simplest icon. */
   PlaneTemplate,       /* The actual icon used to create planes. */
   Missile3D,
   Missile2D,
   MissileTemplate;

long NumPlanes = 0;
double PlaneScale = 1.;
GlgPoint Center;
double MaxDistance;
double UpdateSpeed = 1.;
GlgLong SelectedPlane = -1;
double OpenGLUsed;

GlgAppContext AppContext;   /* Global, used to install a timeout. */

/* Function prototypes */
void LoadPlaneIcons( void );
void SelectPlaneIcons( void );
void GetMapExtent( void );
void CreatePlanes( long NumPlanes );
void AutoPilot( GlgLong plane );
void ChangeDirection( GlgLong plane, GlgBoolean required );
double Distance( GlgPoint * position1, GlgPoint * position2 );
GlgLong DecreaseDistance( GlgLong plane, GlgLong steps1, GlgLong steps2 );
void MakeStep( GlgLong plane, GlgLong num_steps, GlgPoint * position );
void DeletePlane( GlgLong plane, GlgBoolean deleting_all );
void SetPlane( GlgLong plane );
void Update(  GlgAnyType data, GlgIntervalID * id );
double GetData( double min, double max );
void Input( GlgObject viewport, GlgAnyType client_data, GlgAnyType call_data );
GlgBoolean NoPlanesLeft( void );
void AdjustPlanesScale( double factor );
void UnselectPlane( void );
void SelectPlane( GlgLong plane_index );
void DisplaySelectedPlaneInfo( void );
GlgLong GetAdjustedTimeout( GlgULong sec1, GlgULong microsec1, 
                            GlgLong interval );
char * CreateLocationString( double value, GlgBoolean return_lat );
void error( char * string, GlgBoolean quit );

/* Defines a platform-specific program entry point */
#include "GlgMain.h"

/*----------------------------------------------------------------------
| This program simulates a missile fight. It creates a number of planes
| and missiles. Every missile is following one plane until it destroys
| the plane. The number of planes may be specified as a command line
| parameter.
*/
int GlgMain( argc, argv, InitAppContext )
     int argc;
     char *argv[];
     GlgAppContext InitAppContext;
{
#if !USE_GENERATED_CODE   
   char * full_path;
#endif
   long skip;

   AppContext = GlgInit( False, InitAppContext, argc, argv );

   /* Skip options handled by GLG. */
   for( skip = 1; skip < argc; ++skip )
   {
      if( strcmp( argv[ skip ], "-verbose" ) == 0 ||
	 strcmp( argv[ skip ], "-non_verbose" ) == 0 ||
	 strcmp( argv[ skip ], "-glg-enable-opengl" ) == 0 ||
	 strcmp( argv[ skip ], "-glg-disable-opengl" ) == 0 )
        ;    /* Skip arguments handled by GLG. */
      else
      {
         /* Handle the first non-glg argument as a number of planes. */
         if( sscanf( argv[ skip ], "%ld", &NumPlanes ) == 1 &&
            NumPlanes > 0 && NumPlanes * 2 <= MAX_NUM_PLANES )
           ;  /* Accept the number from the command line. */
         else
         {
#ifndef _WINDOWS            
            if( NumPlanes > MAX_NUM_PLANES )
              printf( "Using the default num_planes=10.\n" );
            else
              printf( "Invalid number of planes, using the default num_planes=10.\n" );         
#endif
            NumPlanes = 0;    /* Reset to use default below. */
         }
         break;
      }
   }
   
   if( !NumPlanes )
   {
#ifndef _WINDOWS            
      printf( "To change the number of planes, run the demo \n" );
      printf( "with an optional num_planes argument:\n" );
      printf( "      aircombat <num_planes>\n" );
#endif
      NumPlanes = 10;   /* Use default */
   }

   NumPlanes *= 2;
   
   /* Create a GLG widget. */
#if USE_GENERATED_CODE   
   /* Use a generated drawing image. */
   TopViewport = GlgLoadWidgetFromImage( (char*)DemoData, DemoDataSize );
#else
   /* Take a drawing from the file. */
   full_path = GlgGetRelativePath( argv[0], "demo.g" );
   TopViewport = GlgLoadWidgetFromFile( full_path );
   GlgFree( full_path );
#endif
   if( !TopViewport )
     error( "Can't load drawing file.", True );

   MapViewport = GlgGetResourceObject( TopViewport, "Map" );
   if( !MapViewport )
     error( "Can't find Map viewport.", True );

   InfoDialog = GlgGetResourceObject( MapViewport, "Info" );

   GISObject = GlgGetResourceObject( MapViewport, "GISObject" );
   GetMapExtent();  

   /* Setting widget dimensions using world coordinates [-1000;1000].
      If not set, default dimensions will be used as set in the GLG editor.
      */
   GlgSetGResource( TopViewport, "Point1", -730., -700., 0. );
   GlgSetGResource( TopViewport, "Point2", 730., 700., 0. );

   /* Setting the window title. */
   GlgSetSResource( TopViewport, "ScreenName", 
                    "GLG Air Combat & Map Server Demo" );

   GlgAddCallback( TopViewport, GLG_INPUT_CB, (GlgCallbackProc)Input, NULL );

   GlgSetDResource( InfoDialog, "Visibility", 0. );
   GlgSetDResource( TopViewport, "UpdateSpeed/ValueX", UpdateSpeed );

   LoadPlaneIcons();   

   GlgInitialDraw( TopViewport );

#ifdef _WINDOWS            
   GlgLoadExeIcon( TopViewport, IDI_ICON1 );
#endif

   SelectPlaneIcons();
   CreatePlanes( NumPlanes );

   /* Add a timer to update the simulation. */
   GlgAddTimeOut( AppContext, UPDATE_INTERVAL, (GlgTimerProc)Update, NULL );
   
   return (int) GlgMainLoop( AppContext );
}

/*--------------------------------------------------------------------------
| Creates planes and missiles by copying the template icons and adds them 
| to the drawing.
*/
void CreatePlanes( NumPlanes )
     long NumPlanes;
{
   GlgLong i;
   char * name;

   for( i=0; i<NumPlanes; ++i )
   {
      /* Create a copy of a plane template and add it to the drawing */
      if( IS_MISSILE( i ) )
      {
         Plane( i ) = GlgCopyObject( MissileTemplate );
         name = GlgCreateIndexedName( "Missile ", i );
      }
      else
      {
         Plane( i ) = GlgCopyObject( PlaneTemplate );
         name = GlgCreateIndexedName( "Plane ", i );
      }

      /* Store name. */
      GlgSetSResource( Plane( i ), "Name", name );
      GlgFree( name );

      /* Store a plane index used to identify the plane when it is selected 
         with the mouse. It is stored in a custom property attached to the 
         plane icon. */
      GlgSetDResource( Plane( i ), "PlaneIndex", (double) i );
      
      /* In OpenGL environment, use an additional Z offset for a missile 
         to avoid it visually penetrating a plane's surface when it gets 
         close to the plane.
         */         
      if( OpenGLUsed && IS_MISSILE( i ) )
        GlgSetDResource( Plane( i ), "ZOffset", 300. );

      /* Add planes and missiles to GISArray of GISObject to be able to 
         position them using lat/lon coordinates.
      */
      GlgAddObjectToBottom( GISObject, Plane( i ) );
      GlgDropObject( Plane( i ) );

      /* Set initial simulation parameters */
      PlaneDestroyed( i ) = False;
      PlaneCorrectingDistance( i ) = 0;
      PlaneMissileDelay( i ) = 0;

      if( IS_PLANE( i ) )
      {
         /* It's a plane: set a random initial position */
         PlaneX( i ) = Center.x + MaxDistance * GetData( -1., 1. );
         PlaneY( i ) = Center.y + MaxDistance * GetData( -1., 1. );
         PlaneZ( i ) = Center.z + MaxDistance * GetData( -1., 1. );
      }
      else
      {
         /* It's a missile: set in some proximity of a plane. */
         PlaneX( i ) = PlaneX( i - 1 ) + MaxDistance * GetData( -0.3, 0.3 );
         PlaneY( i ) = PlaneY( i - 1 ) + MaxDistance * GetData( -0.3, 0.3 );
         PlaneZ( i ) = PlaneZ( i - 1 );   /* Set at the same depth */
      }

      if( IS_MISSILE( i ) )   /* Missile */
        /* Set the missiles initial speed to be lower */
        PlaneSpeed( i ) = MISSILE_SPEED * PLANE_SPEED;
      else   /* Plane */
	PlaneSpeed( i ) = PLANE_SPEED;

      PlaneChangeState( i ) = 1;
      SetPlane( i );               /* Set initial plane parameters. */
      PlaneChangeState( i ) = 0;
   }
   AdjustPlanesScale( PlaneScale ); /* Set initial plane scale */
}

/*--------------------------------------------------------------------------
| Loads plane icons from the plane palette defined in the drawing.
*/
void LoadPlaneIcons()
{
   GlgObject plane_palette;

   /* Find a plane palette. */
   plane_palette = GlgGetResourceObject( TopViewport, "PlanePalette" );

   /* Get the plane and missile icons. */
   Plane3DFull  = GlgGetResourceObject( plane_palette, "plane_3D_full" );
   Plane3DLight = GlgGetResourceObject( plane_palette, "plane_3D_light" );
   Plane2D      = GlgGetResourceObject( plane_palette, "plane_2D" );
   Missile3D    = GlgGetResourceObject( plane_palette, "missile_3D_full" );
   Missile2D    = GlgGetResourceObject( plane_palette, "missile_2D" );
   
   /* Keep the plane icons around. */
   GlgReferenceObject( Plane3DFull );
   GlgReferenceObject( Plane3DLight );
   GlgReferenceObject( Plane2D );
   GlgReferenceObject( Missile3D );
   GlgReferenceObject( Missile2D );

   /* Delete the palette from the drawing */
   GlgDeleteThisObject( TopViewport, plane_palette );
}

/*--------------------------------------------------------------------------
| Select the icons to use depending on the number of planes and missiles
| and the availability of the OpenGL driver.
*/
void SelectPlaneIcons()
{
   /* Must be done after GlgInitalDraw() */
   GlgGetDResource( MapViewport, "OpenGL", &OpenGLUsed );

   /* Use simpler icons for large number of planes + missiles and 
      depending on the OpenGL use.
   */
   if( OpenGLUsed )
   {
      if( NumPlanes <= 100 )
      {
         PlaneTemplate = GlgReferenceObject( Plane3DFull );
         MissileTemplate = GlgReferenceObject( Missile3D ); 
      }
      else if( NumPlanes <= 250 )
      {
         PlaneTemplate = GlgReferenceObject( Plane3DLight );
         MissileTemplate = GlgReferenceObject( Missile3D ); 
      }
      else
      {
         PlaneTemplate = GlgReferenceObject( Plane2D );
         MissileTemplate = GlgReferenceObject( Missile2D ); 
      }
   }
   else /* no OpenGL */
   {
      if( NumPlanes <= 60 )
      {
         PlaneTemplate = GlgReferenceObject( Plane3DFull );
         MissileTemplate = GlgReferenceObject( Missile3D ); 
      }
      else if( NumPlanes <= 150 )
      {
         PlaneTemplate = GlgReferenceObject( Plane3DLight );
         MissileTemplate = GlgReferenceObject( Missile3D ); 
      }
      else
      {
         PlaneTemplate = GlgReferenceObject( Plane2D );
         MissileTemplate = GlgReferenceObject( Missile2D ); 
      }
   }

   /* Destroy: no longer needed. */
   GlgDropObject( Plane3DFull );
   GlgDropObject( Plane3DLight );
   GlgDropObject( Plane2D );
   GlgDropObject( Missile3D );
   GlgDropObject( Missile2D );

   Plane3DFull = (GlgObject)0;
   Plane3DLight = (GlgObject)0;
   Plane2D = (GlgObject)0;
   Missile3D = (GlgObject)0;
   Missile2D = (GlgObject)0;
}

/*--------------------------------------------------------------------------
| 
*/
void GetMapExtent()
{
   GlgPoint extent;

   GlgGetGResource( GISObject, "GISCenter", &Center.x, &Center.y, &Center.z );
   GlgGetGResource( GISObject, "GISExtent", &extent.x, &extent.y, &extent.z );
   MaxDistance = fmin( extent.x / 2., extent.y / 2. ) * MAX_DISTANCE;
}

/*----------------------------------------------------------------------
| Simulates a plane or a missile.
*/
void AutoPilot( plane )
     GlgLong plane;  /* Plane index */
{
   if( PlaneDestroyed( plane ) )
     return;

   if( IS_PLANE( plane ) )
   {
      if( Distance( &PlanePosition( plane ), &Center ) > MaxDistance )
      {
	 /* Change direction to correct the distance from a center */
	 if( !PlaneCorrectingDistance( plane ) )
	   ChangeDirection( plane, True );
      }
      else if( GetData( 0., 1. ) > CHANGE_THRESHOLD )
	ChangeDirection( plane, False );  /* Random direction change */
   }
   else   /* Missile */
   {
      ++PlaneMissileDelay( plane );
      if( ! ( PlaneMissileDelay( plane ) % MISSILE_DELAY ) )
	/* Adjust missile to the new plane position */
	ChangeDirection( plane, False );
   }

   /* Move the plane by one simulation step. */
   MakeStep( plane, 1, (GlgPoint *)0 );
   
   if( !PlaneDestroyed( plane ) )
     SetPlane( plane );  /* Set plane position and angles in the drawing */
}

/*----------------------------------------------------------------------
| For a missile: adjust the missile's direction to point to the plane it
|   follows.
| For a plane:
|   a) if required==True, change the plane direction to correct the
|      distance from the center to avoid going off the screen.
|   b) if required==False, randomly change the plane's direction to make
|      it more complicated for a missile to catch it.
*/
void ChangeDirection( plane, required )
     GlgLong plane;   /* Plane index */
     GlgBoolean required;
{
   double distance, dx, dy, dz, angle_y, angle_z;

   if( IS_PLANE( plane ) )
   {
      distance = Distance( &PlanePosition( plane ), &Center );
      
      /* Set flags to indicate a change in progress */
      PlaneChangeState( plane ) = TRANSITION_NUM - 1; /* Start a new change */
      if( required )
	PlaneCorrectingDistance( plane ) = DELAY * TRANSITION_NUM + 1;
      
      while( 1 )
      {
	 /* Choose a new random direction */
	 PlaneAngleXChange( plane ) = 60. * GetData( -1., 1. ) / TRANSITION_NUM;
	 PlaneAngleYChange( plane ) = 60. * GetData( -1., 1. ) / TRANSITION_NUM;
	 PlaneAngleZChange( plane ) = 360. * GetData( 0., 1. ) / TRANSITION_NUM;

	 /* Test if it lowers the distance from the center, if required. */
	 if( !required ||
	    DecreaseDistance( plane, 0, DELAY * TRANSITION_NUM + 1 ) )
	   break;
      }
   }
   else  /* Missile */
   {
      /* Calculate the angles to direct the missile at the plane. */
      dx = PlaneX( plane - 1 ) - PlaneX( plane );
      dy = PlaneY( plane - 1 ) - PlaneY( plane );
      dz = PlaneZ( plane - 1 ) - PlaneZ( plane );

      if( !dx )
	angle_z = ( dy > 0. ? 90. : 270. );
      else
      {
	 angle_z = atan( dy / dx );
	 angle_z = DEG( angle_z );
	 if( dx < 0. )
	   angle_z += 180.;
      }

      if( !dx )
	 angle_y = ( dz > 0. ? 270. : 90. );
      else
      {
	 angle_y = atan( dz / dx );
	 angle_y = DEG( angle_y );
      }
      
      /* Change direction instantly (it has a much smaller inertia). */
      PlaneAngleX( plane ) = PlaneAngleX( plane - 1 ); /* Take from a plane. */
      PlaneAngleY( plane ) = angle_y;
      PlaneAngleZ( plane ) = angle_z;
      PlaneChangeState( plane ) = 1;

      /* Randomly speed the missile up until it is faster then the plane. */
      if( PlaneSpeed( plane ) < 1.2 * PLANE_SPEED && GetData( 0., 1. ) > 0.5 )
	PlaneSpeed( plane ) *= 1.04;
   }
}

/*----------------------------------------------------------------------
| Calculate and return a distance between two positions.
*/
double Distance( position1, position2 )
     GlgPoint * position1, * position2;
{
   double dx, dy, dz;

   dx = position1->x - position2->x;
   dy = position1->y - position2->y;
   dz = position1->z - position2->z;

   return sqrt( dx * dx + dy * dy + dz * dz );
}

/*----------------------------------------------------------------------
| Tests whether or not the distance will decrease after the required
| number of simulation steps. Compares the distance after steps1 number
| of steps with the distance after steps2 number of steps.
*/
GlgLong DecreaseDistance( plane, steps1, steps2 )
     GlgLong plane, steps1, steps2;
{
   GlgPoint
     position1,
     position2;

   MakeStep( plane, steps1, &position1 );
   MakeStep( plane, steps2, &position2 );
   return Distance( &position2, &Center ) < Distance( &position1, &Center );
}

/*----------------------------------------------------------------------
| Makes the requested number of simulation steps and returns the
| calculated postion of a plane after that.
| If the position parameter is not NULL, it is a trial step; the
| calculated values are returned in this structure and the plane
| parametrs are restored afterwards.
| If the parameter is NULL, it is a real step affecting the plane.
*/
void MakeStep( plane, num_steps, position )
     GlgLong
        plane,                   /* Plane index */
        num_steps;
     GlgPoint * position; /* Return value */
{
   struct Planes buf_struct;
   GlgLong i;

   if( position )
     buf_struct = PlaneArray[ plane ];   /* Save */

   for( i=0; i<num_steps; ++i )
   {
      /* Make a step in the current direction */
      PlanePosition( plane ).x += PlaneSpeed( plane ) * UpdateSpeed *
	cos( RAD( PlaneAngleZ( plane ) ) ) *
	  cos( RAD( PlaneAngleY( plane ) ) );
      PlanePosition( plane ).y += PlaneSpeed( plane ) * UpdateSpeed *
	sin( RAD( PlaneAngleZ( plane ) ) ) *
	  cos( RAD( PlaneAngleY( plane ) ) );
      PlanePosition( plane ).z += PlaneSpeed( plane ) * UpdateSpeed *
	sin( RAD( PlaneAngleY( plane ) ) ) *
	  cos( RAD( PlaneAngleZ( plane ) ) );

      /* If a direction change is in progress, adjust the plane angles. */
      if( PlaneChangeState( plane ) && IS_PLANE( plane ) )
      {
	 PlaneAngleX( plane ) += PlaneAngleXChange( plane );
	 PlaneAngleY( plane ) += PlaneAngleYChange( plane );
	 PlaneAngleZ( plane ) += PlaneAngleZChange( plane );

	 if( PlaneAngleX( plane ) >= 360. )
	   PlaneAngleX( plane ) -= 360.;
	 if( PlaneAngleY( plane ) >= 360. )
	   PlaneAngleY( plane ) -= 360.;
	 if( PlaneAngleZ( plane ) >= 360. )
	   PlaneAngleZ( plane ) -= 360.;
	 
	 --PlaneChangeState( plane );
      }

      if( PlaneCorrectingDistance( plane ) )
	--PlaneCorrectingDistance( plane );
   }

   if( position )  /* Just checking the distance: restore and return. */
   {
      *position = PlanePosition( plane );  /* Return the result */
      PlaneArray[ plane ] = buf_struct;   /* Restore */
   }
   else  /* Real step: if it is a missile, check if it got its plane. */
     if( IS_MISSILE( plane ) &&
	Distance( &PlanePosition( plane - 1 ), &PlanePosition( plane ) ) < 
         DESTROY_DISTANCE * MaxDistance )
     {
	/* Got it: Delete both the plane and the missile. */
	DeletePlane( plane - 1, False );
	DeletePlane( plane, False );
	
	/* Restart if no more planes left. */
	if( NoPlanesLeft() )
	{
	   CreatePlanes( NumPlanes );
	   GlgUpdate( TopViewport );
	}
     }
}

/*----------------------------------------------------------------------
| Deletes the plane or missile from the drawing. Flashes the size of a
| missile for an explosive effect.
*/
void DeletePlane( plane, deleting_all )
     GlgLong plane;
     GlgBoolean deleting_all;
{
   double scale;
   GlgLong i;

   if( plane == SelectedPlane )
     UnselectPlane();

   if( IS_MISSILE( plane ) ) /* Create an explosive effect. */
   {
      /* Speed it up for large number of planes when deleting all - 
         do it only a few times. */
      if( !deleting_all ||
          NumPlanes > 3 && ( ( plane - 1 ) % ( NumPlanes / 3 ) ) == 0 )
      {
         for( i=0; i<6; ++i )
         {
            GlgGetDResource( Plane( plane ), "Scale", &scale );
            if( (i+1) % 2 )
              GlgSetDResource( Plane( plane ), "Scale", scale );
            else
              GlgSetDResource( Plane( plane ), "Scale", scale * 1.3 );
            GlgUpdate( MapViewport );
            GlgSleep( 50 );
         }
      }
   }

   /* Delete the plane from the drawing */
   if( !GlgDeleteThisObject( GISObject, Plane( plane ) ) )
     GlgError( GLG_USER_ERROR, "Cannot find the plane.\n" );

   PlaneDestroyed( plane ) = True;     
}

/*----------------------------------------------------------------------
| Updates the plane in the drawing with the new values. Ignores 3D
| rotation for a missle.
*/
void SetPlane( plane )
     GlgLong plane;
{
   /* Plane is changing its direction. */
   if( PlaneChangeState( plane ) )
   {
      GlgSetDResource( Plane( plane ), "AngleX", PlaneAngleX( plane ) );
      GlgSetDResource( Plane( plane ), "AngleY", PlaneAngleY( plane ) );
      GlgSetDResource( Plane( plane ), "AngleZ", PlaneAngleZ( plane ) );

      if( IS_MISSILE( plane ) )     /* Missile: an instant change */
	PlaneChangeState( plane ) = 0;
   }

   GlgSetGResource( Plane( plane ), "Position",
                    PlaneX( plane ), PlaneY( plane ), PlaneZ( plane ) );
}

/*----------------------------------------------------------------------
| Makes one simulation step for every plane or missile.
*/
void Update( GlgAnyType data, GlgIntervalID * id )
{
   GlgULong sec1, microsec1;
   GlgLong timer_interval;
   GlgLong i;

   GlgGetTime( &sec1, &microsec1 );  /* Start time */

   for( i=0; i<NumPlanes; ++i )
     AutoPilot( i );

   DisplaySelectedPlaneInfo();

   GlgUpdate( TopViewport );  /* Update the drawing after changes. */

   /* Synchronize the display connection to make it more responsive. */
   GlgSync( TopViewport );

   timer_interval = GetAdjustedTimeout( sec1, microsec1, UPDATE_INTERVAL );

   GlgAddTimeOut( AppContext, timer_interval, (GlgTimerProc)Update, NULL );
}

/*----------------------------------------------------------------------
| 
*/
GlgLong GetAdjustedTimeout( GlgULong sec1, GlgULong microsec1, 
			   GlgLong interval )
{
   GlgULong sec2, microsec2;
   GlgLong elapsed_time, adj_interval;

   GlgGetTime( &sec2, &microsec2 );  /* End time */
   
   /* Elapsed time in millisec */
   elapsed_time = 
     ( sec2 - sec1 ) * 1000 + (GlgLong) ( microsec2 - microsec1 ) / 1000;

   /* Maintain constant update interval regardless of the system speed. */
   if( elapsed_time + 20 >= interval )
      /* Slow system: update as fast as we can, but allow a small interval 
         for handling input events. */
     adj_interval = 20;
   else
     /* Fast system: keep constant update interval. */
     adj_interval = interval - elapsed_time;

#if DEBUG_TIMER
   printf( "sec= %ld, msec= %ld\n", 
           (long)( sec2 - sec1 ), (long)( microsec2 - microsec1 ) );
   printf( "*** elapsed= %ld, requested= %ld, adjusted= %ld\n",
           (long)elapsed_time, (long)interval, (long)adj_interval );
#endif

   return adj_interval;
}

/*----------------------------------------------------------------------
| Returns a random number in the requested range.
*/
double GetData( double min, double max )
{
   return GlgRand( min, max );
}

/*----------------------------------------------------------------------
| Processes buttons' and sliders' events.
*/
void Input( top_viewport, client_data, call_data )
     GlgObject top_viewport;
     GlgAnyType client_data;
     GlgAnyType call_data;
{
   GlgObject message_obj;
   char
     * format,
     * action,
     * origin;
   GlgLong i;

   message_obj = (GlgObject) call_data;

   GlgGetSResource( message_obj, "Format", &format );
   GlgGetSResource( message_obj, "Action", &action );
   GlgGetSResource( message_obj, "Origin", &origin );

   /* Handle window closing. Could use viewport's name if there is more than
      one top viewport. */
   if( strcmp( format, "Window" ) == 0 &&
      strcmp( action, "DeleteWindow" ) == 0 )
     exit( GLG_EXIT_OK );

   if( strcmp( format, "Slider" ) == 0 )
   {
      if( strcmp( action, "ValueChanged" ) != 0 )
        return;

      if( strcmp( origin, "UpdateSpeed" ) == 0 )
        /* Query the new value of the UpdateSpeed Slider (relative value). */
        GlgGetDResource( message_obj, "ValueX", &UpdateSpeed ); 
   }
   else if( strcmp( format, "Button" ) == 0 )
   {
      if( strcmp( action, "Activate" ) != 0 )
        return;

      if( strcmp( origin, "Restart" ) == 0 )  /* Restart */
      {
	 for( i=0; i<NumPlanes; ++i )
	   if( !PlaneDestroyed( i ) )
	     DeletePlane( i, True );

	 CreatePlanes( NumPlanes );
	 GlgUpdate( TopViewport );
      }
      else if( strcmp( origin, "BigPlanes" ) == 0 )  /* Increase plane size */
      {
	 PlaneScale *= 1.5;
	 AdjustPlanesScale( 1.5 );
      }
      else if( strcmp( origin, "SmallPlanes" ) == 0 ) /* Decrease plane size */
      {
	 PlaneScale /= 1.5;
	 AdjustPlanesScale( 1. / 1.5 );
      }
      else if( strcmp( origin, "ClosePlaneInfo" ) == 0 )
      {
	 /* Unselect the plane and close its information popup dialog. */
	 UnselectPlane();
	 GlgUpdate( TopViewport );	 
      }
      else if( strcmp( origin, "Quit" ) == 0 )  /* Quit */
	exit( GLG_EXIT_OK );
   }
   /* Process mouse clicks on plane icons, implemented as an Action with
      the PlaneSelection label attached to an icon and activated on a
      mouse click. 
   */
   else if( strcmp( format, "CustomEvent" ) == 0 )
   {
      char * event_label;

      GlgGetSResource( message_obj, "EventLabel", &event_label );

      /* Plane icon was selected */
      if( strcmp( event_label, "PlaneSelection" ) == 0 )
      {
	 double plane_index;

	 /* Get plane index */
	 GlgGetDResource( message_obj, "Object/PlaneIndex", &plane_index );
	 SelectPlane( (GlgLong) plane_index );
	 GlgUpdate( TopViewport );	 
      }
   }
}

/*----------------------------------------------------------------------
| Returns a number of planes left.
*/
GlgBoolean NoPlanesLeft()
{
   GlgLong i;

   for( i=0; i<NumPlanes; ++i )
     if( !PlaneDestroyed( i ) )
       return False;

   return True;
}

#define MAX_PLANE_SCALE   3.375

/*----------------------------------------------------------------------
| Returns a number of planes left.
*/
void AdjustPlanesScale( factor )
     double factor;
{
   GlgLong i;
   double scale;

   for( i=0; i<NumPlanes; ++i )
     if( !PlaneDestroyed( i ) )
     {
	GlgGetDResource( Plane( i ), "Scale", &scale );

        scale *= factor;        
        if( scale > MAX_PLANE_SCALE )
          scale = MAX_PLANE_SCALE;

	GlgSetDResource( Plane( i ), "Scale", scale );
     }
   GlgUpdate( MapViewport );
}

/*----------------------------------------------------------------------
|
*/
void SelectPlane( plane_index )
  GlgLong plane_index;
{
   char * plane_name;

   if( SelectedPlane == -1 )
     /* No previously selected plane: activate an information popup dialog. */
     GlgSetDResource( InfoDialog, "Visibility", 1. );
   else 
     /* The dialog is already active, just unselect the previously selected 
        plane */
     if( !PlaneDestroyed( SelectedPlane ) )
       GlgSetDResource( Plane( SelectedPlane ), "SelectedState", 0. );

   SelectedPlane = plane_index;

   /* Display selected plane or missile info stored as its name. */
   GlgGetSResource( Plane( SelectedPlane ), "Name", &plane_name );
   GlgSetSResource( InfoDialog, "PlaneName", plane_name );

   /* Set the SelectedState resource which controls an icon's color. */
   GlgSetDResource( Plane( plane_index ), "SelectedState", 1. );
}

/*----------------------------------------------------------------------
|
*/
void UnselectPlane()
{
   if( SelectedPlane == -1 )
     return;
   
   if( !PlaneDestroyed( SelectedPlane ) )
     GlgSetDResource( Plane( SelectedPlane ), "SelectedState", 0. );

   GlgSetDResource( InfoDialog, "Visibility", 0. );
   SelectedPlane = -1;
}

/*----------------------------------------------------------------------
|
*/
void DisplaySelectedPlaneInfo()
{
   double roll, pitch, yaw;
   char
     * lat_string,
     * lon_string;

   if( SelectedPlane == -1 )
     return;

   roll = PlaneAngleX( SelectedPlane );
   pitch = PlaneAngleY( SelectedPlane );
   yaw = PlaneAngleZ( SelectedPlane ) - 90.;

   while( roll > 180. )
     roll -= 360.;
   while( pitch > 180. )
     pitch -= 360.;
   while( yaw > 180. )
     yaw -= 360.;

   GlgSetDResource( InfoDialog, "Roll",  roll );
   GlgSetDResource( InfoDialog, "Pitch", pitch );
   GlgSetDResource( InfoDialog, "Yaw",   yaw );

   lat_string = CreateLocationString( PlaneY( SelectedPlane ), True );
   lon_string = CreateLocationString( PlaneX( SelectedPlane ), False );

   GlgSetSResource( InfoDialog, "Lat", lat_string );
   GlgSetSResource( InfoDialog, "Lon", lon_string );

   GlgFree( lat_string );
   GlgFree( lon_string );
}

/*----------------------------------------------------------------------
| Generate a location info string by converting +- signs info into the
| N/S, E/W suffixes, and decimal fraction to deg, min, sec.
*/
char * CreateLocationString( double value, GlgBoolean return_lat )
{
   long deg, min, sec;
   char
     suffix,
     buffer[ 100 ];

   if( return_lat )
   {
      if( value < 0. )
      {
         value = -value;
         suffix = 'S';
      }
      else
        suffix = 'N';
      
      deg = value;
      min = ( value - deg ) * 60.;
      sec = ( value - deg - min / 60. ) * 3600.;

      sprintf( buffer, "%ld.%.2ld'%.2ld\"%c", deg, min, sec, suffix ); 
   }
   else  /* return lon */
   {
      if( value < 0. )
      {
         value = -value;
         suffix = 'W';
      }
      else if( value >= 360. )
      {
         value -= 360.;
         suffix = 'E';
      }
      else if( value >= 180. )
      {
         value = 180. - ( value - 180. );
         suffix = 'W';
      }
      else
        suffix = 'E';

      deg = value;
      min = ( value - deg ) * 60.;
      sec = ( value - deg - min / 60. ) * 3600.;
      sprintf( buffer, "%ld.%.2ld'%.2ld\"%c", deg, min, sec, suffix );
   }
   
   return GlgStrClone( buffer );
}

/*----------------------------------------------------------------------
|
*/
void error( char * string, GlgBoolean quit )
{
   GlgError( GLG_USER_ERROR, string );
   if( quit )
     exit( GLG_EXIT_ERROR );
}
