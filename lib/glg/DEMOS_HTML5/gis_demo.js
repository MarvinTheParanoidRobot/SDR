//////////////////////////////////////////////////////////////////////////////
// GIS Air Traffic Monitoring Demo: an example of using the GLG Map Server
// integrated in the GLG drawing.
//
// The demo is written in pure HTML5 and JavaScript. The source code of the
// demo uses the GLG Toolkit JavaScript Library supplied by the included
// Glg*.js and GlgToolkit*.js files. The GLG library loads a GLG drawing
// and renders it on a web page, providing an API to handle user interaction
// with graphical objects in the drawing.
//
// The drawings are created using the GLG Graphics Builder, an interactive
// editor that allows to create grahical objects and define their dynamic
// behavior without any programming. The airplane icons are dynamic
// GLG objects created with the Graphics Builder.
//
// The background map is generated by the GLG Map Server, which is integrated
// inside of a GLG drawing as a GLG GIS Object. The GIS Object takes a
// complete care of the map display, automatically generating Map Server
// requests to re-generate the image when the map is panned or zoomed.
//
// The demo uses asyncronous map loading: when the map is zoomed or scrolled,
// the drawing is changed right away, while the new map will appear when it's
// loaded. The GLG Air Traffic Control Demo demonstrates an alternative
// approach that uses an asynchronous map loading request to load a map:
// when the map is zoomed or scrolled, the program will continue to operate
// in the old zoom or pan state and will switch to the new zoom or pan state
// when the new map is ready. 
//
// Except for the changes to comply with the JavaScript syntax, this source
// is identical to the source code of the corresponding C/C++/C# and Java
// desktop versions of the demo.
//
// This demo uses the GLG Map Server to display a map.
// The Map Server has to be installed either on the local host or on a
// remote web server. After the Map Server has been installed, modify the
// source code to set the SuppliedMapServerURL variable to point to the
// Map Server location.
//////////////////////////////////////////////////////////////////////////////

// Get a handle to the GLG Toolkit library.
var GLG = new GlgToolkit();

// Debugging aid: uncomment the next line to throw an exception on a GLG error.
//GLG.ThrowExceptionOnError( true, true, true );

// Set initial size of the drawing.
SetDrawingSize( false );

// Increase canvas resoultion for mobile devices.
var CoordScale = SetCanvasResolution();

/* Loads all drawings used by the program and invokes the LoadDrawing
   function when done.
*/
LoadAssets( LoadDrawing );

//////////////////////////////////////////////////////////////////////////////
function LoadDrawing()
{
   /* Load a drawing from the gis_demo.g file. 
      The LoadCB callback will be invoked when the drawing has been loaded.
   */
   var drawing_file = ( MobileVersion ? "gis_demo2.g" : "gis_demo.g" );
   
   GLG.LoadWidgetFromURL( drawing_file, null, LoadCB, null );
}

//////////////////////////////////////////////////////////////////////////////
function LoadCB( drawing, data, path )
{
   if( drawing == null )
   {
      window.alert( "Can't load drawing, check console message for details." );
      return;
   }
                
   // Define the element in the HTML page to display the drawing in.
   drawing.SetParentElement( "glg_area" );
   
   // Disable viewport border to use the border of the glg_area.
   drawing.SetDResource( "LineWidth", 0 );

   StartGISDemo( drawing );
}

//////////////////////////////////////////////////////////////////////////////
// Control variables and constants
//////////////////////////////////////////////////////////////////////////////

/* This demo uses the GLG Map Server to display a map.
   The Map Server has to be installed either on the local host or on a
   remote web server. After the Map Server has been installed, set the 
   SuppliedMapServerURL variable to point to the Map Server location:
   for example:
     SuppliedMapServerURL = "http://localhost/cgi-bin/GlmScript";
   or
     SuppliedMapServerURL = "http://www.myserver.com/cgi-bin/GlmScript";
   The SuppliedMapServerURL value overrides the URL of the GIS object in the
   drawing.
*/
var SuppliedMapServerURL = null;    /* String */

// Controls the plane speed used to simulate moving airplanes.
var PlaneSpeed = 0.001;    // Relative units   
const MaxZoomSpeed = 5.0;     // In XY Coordinates

const
   UpdateInterval = 50,  // Update interval in milliseconds.
   USZoomDelay1 = 4000,  // Delay to zoom to the US area to show details.
   USZoomDelay2 = 1000;  // Delay to remove US zooming message.

const
   SMALL_SIZE  = 0.23,
   MEDIUM_SIZE = 0.33,
   BIG_SIZE =    0.43;

var
   Drawing,         /* GlgObject */
   PositionObject,  /* GlgObject */
   PositionArea;    /* GlgObject */

var NodeTemplate = new Array( 2 );  /* GlgObject[2] */
var PlaneTemplate = new Array( 2 ); /* GlgObject[2] */
var Map = new Array( 2 );           /* GlgObject[2] */
var GISObject = new Array( 2 );     /* GlgObject[2] */
var NodeGroup = new Array( 2 );     /* GlgObject[2] */
var PlaneGroup = new Array( 2 );    /* GlgObject[2] */
var MapProjection = new Array( 2 ); /* int[2] */
var MapLoaded = new Array( 2 );     /* boolean[2] */

// Store initial extent and center, used to reset the map.
var InitExtent = new Array( 2 );    /* GlgPoint[2] */
var InitCenter = new Array( 2 );    /* GlgPoint[2] */

var PlaneSize = MEDIUM_SIZE;       /* double */

var 
   NumPlanes = 10,               /* int - number of planes to use in the demo */
   NumNodes;                     /* int */
    
var
   /* If true, pan the map to make the selected plane visible in the current
      zoomed area.
   */
   LockSelectedPlane = false,     /* boolean */
   CityLabels = true,             /* boolean */
   StateDisplay = true,           /* boolean */
   SuspendPromptUpdates = false,  /* boolean */
   PanMode = false,               /* boolean */
   PerformUpdates = true,         /* boolean */
   StartDragging = false;         /* boolean */
 
// Temp variables: allocate once
var
   lat_lon = GLG.CreateGlgPoint( 0, 0, 0 ),          /* GlgPoint */
   position = GLG.CreateGlgPoint( 0, 0, 0 ),         /* GlgPoint */
   old_position = GLG.CreateGlgPoint( 0, 0, 0 ),     /* GlgPoint */
   new_position = GLG.CreateGlgPoint( 0, 0, 0 ),     /* GlgPoint */
   last_xyz = GLG.CreateGlgPoint( 0, 0, 0 ),         /* GlgPoint */
   curr_xyz = GLG.CreateGlgPoint( 0, 0, 0 ),         /* GlgPoint */
   point = GLG.CreateGlgPoint( 0, 0, 0 ),            /* GlgPoint */
   util_point = GLG.CreateGlgPoint( 0, 0, 0 ),       /* GlgPoint */
   selection_rect = GLG.CreateGlgCube( null, null ); /* GlgCube */

var PlaneArray;                /* PlaneData[] */
var SelectedPlane = null;      /* PlaneData */

var timer = null;
var zoom_timer = null;

/* Array of icons to place on the map as GLG objects in addition to the icons
   defined in GIS server's data. The icons that use GLG objects may be 
   selected with the mouse and their attributes can be changed dynamically, 
   based on data. When the mouse moves over an icon, it may be highlighted 
   with a different color or a tooltip may be displayed. 
*/
var NodeArray =
  [ new NodeData( "Boston",        -71.01789,  42.33602 ),
    new NodeData( "New York",      -73.97213,  40.77436 ),
    new NodeData( "San Francisco", -122.55478, 37.79325 ),
    new NodeData( "Miami",         -80.21084,  25.77566 ),
    new NodeData( "Seattle",       -122.35032, 47.62180 ),
    new NodeData( "Houston",       -95.38672,  29.76870 ),
    new NodeData( "Denver",        -104.87265, 39.76803 ),
    new NodeData( "Minneapolis",   -93.26684,  44.96185 ),
    new NodeData( "Chicago",       -87.68496,  41.83705 ),
    new NodeData( "Dallas",        -96.76524,  32.79415 ) ];

//////////////////////////////////////////////////////////////////////////////
function StartGISDemo( drawing )
{
   Drawing = drawing;

   InitDrawing();
   InitIcons();

   Drawing.SetupHierarchy();

   /* Adjust selected region on the thumbnail map to match the zoomed area 
      of the detailed map.
   */
   SetSelectedArea();

   SetMapLoading( 0, true );
   SetMapLoading( 1, true );

   Drawing.Update();
   
   if( MobileVersion )
     PlaneSpeed = 0.005;

   timer = setTimeout( UpdatePlanes, UpdateInterval );

   // Zoom to the US area after a few seconds to show details.        
   zoom_timer = setTimeout( ZoomToUS, USZoomDelay1 );
}

//////////////////////////////////////////////////////////////////////////////
function InitDrawing()
{
   // Show mouse over tooltips right away.
   Drawing.SetDResource( "$config/GlgMouseTooltipTimeout", 0.05 );

   Drawing.SetDResource( "$config/GlgPickResolution", 10 * CoordScale );

   Map[ 0 ] = Drawing.GetResourceObject( "TopMap" );   // Thumbnail map
   Map[ 1 ] = Drawing.GetResourceObject( "Map" );      // Detailed map

   /* Display thumbnail map in a floating dialog at run time. It is kept 
      as a child viewport in the drawing for the convinience of editing.
   */
   Map[ 0 ].SetDResource( "ShellType", GLG.GlgShellType.DIALOG_SHELL );
   Map[ 0 ].SetSResource( "Screen/ScreenName", "Globe View" );

   // Set an initial position of the thumbnail map dialog.
   Map[ 0 ].SetGResource( "Position", 50, MobileVersion ? -1025 : -1120, 0 );

   for( var i=0; i<2; ++i )   // For each map window
   {
      // Get IDs of the GIS objects in each of the map viewports. 
      GISObject[ i ] = Map[ i ].GetResourceObject( "GISObject" );

      if( SuppliedMapServerURL != null )
        // Override the URL defined in the drawing.
        GISObject[ i ].SetSResource( "GISMapServerURL", SuppliedMapServerURL );

      /* Query and store the GIS projection (ORTHOGRAPHIC or RECTANGULAR)
         used to render the map.
      */
      MapProjection[ i ] =
        Math.trunc( GISObject[ i ].GetDResource( "GISProjection" ) );

      /* Set the GIS Zoom mode. It was set and saved with the drawing, 
         but do it again programmatically just in case.
      */
      Map[ i ].SetZoomMode( null, GISObject[ i ], null, 
                            GLG.GlgZoomMode.GIS_ZOOM_MODE );

      // Store initial map extent for resetting after zooming.
      InitExtent[i] = GISObject[ i ].GetGResource( "GISExtent" );
      InitCenter[i] = GISObject[ i ].GetGResource( "GISCenter" );
   }

   /* Add Input and Trace callbacks used to handle user interaction. */
   Drawing.AddListener( GLG.GlgCallbackType.INPUT_CB, InputCallback );
   Drawing.AddListener( GLG.GlgCallbackType.TRACE_CB, TraceCallback );
}

//////////////////////////////////////////////////////////////////////////
// Initializes icons in the drawing
//////////////////////////////////////////////////////////////////////////
function InitIcons()
{
   var i;

   // Get the palette containing templates for plane and node icons.
   var palette = Drawing.GetResourceObject( "Palette" );

   // Delete it from the drawing
   Drawing.DeleteThisObject( palette );

   /* Get node and plane templates from the palette. Two sets of templates
      are used: smaller icons for the thumbnail view and more elaborate 
      ones for the detailed map.
   */
   for( i=0; i<2; ++i )
   {
      NodeTemplate[ i ] =
        palette.GetResourceObject( i == 0 ? "Node1" : "Node2" );

      PlaneTemplate[ i ] = 
        palette.GetResourceObject( i == 0 ? "Plane1" : "Plane2" );

      /* If the icon is not a marker (IconScale resource exists), set the
         icon's size.
      */
      var resource = PlaneTemplate[ i ].GetResourceObject( "IconScale" );
      if( resource != null )
        resource.SetDResource( null, PlaneSize );
   }

   NumNodes = NodeArray.length;

   // Create and initialize plane structures used for simulation.
   PlaneArray = new Array( NumPlanes );
   for( i=0; i < NumPlanes; ++i )
   {
      PlaneArray[ i ] = new PlaneData();
      PlaneArray[ i ].name = i.toString();
   }
      
   // Add node and plane icons to both thumbnail and detailed map.
   for( i=0; i<2; ++i )
   {	 
      CreateAirportIcons( i ); // Add airport icons
      CreatePlaneIcons( i );   // Add plane icons
   }

   // Start all planes.
   for( i=0; i < NumPlanes; ++i )
     StartPlane( PlaneArray[ i ], true );

   /* Selected area annotates the currently viewed area of the detailed map 
      in the thumbnail map view. Reorder SelectedArea on top of icons
      (last in the array).
   */
   var selected_area =   /* GlgObject */
     GISObject[ 0 ].GetResourceObject( "GISArray/SelectedArea" );
   GISObject[ 0 ].ReorderElement( GISObject[ 0 ].GetIndex( selected_area ),
                                  GISObject[ 0 ].GetSize() - 1 );

   /* Set state display on the thumbnail map. Airport labels on the detailed
      map are handled by HandleZoomLevel(). 
   */
   SetGISLayers( 0 );

   /* Demos starts with the whole word view, then zooms to the US area
      in a few seconds to show more details. Set initial parameters
      for the whole world view.
   */
   HandleZoomLevel();

   InitSelection();  // Select some plane.

   // Store objects used to display lat/lon on mouse move.
   PositionArea = Drawing.GetResourceObject( "PositionArea" );
   PositionObject = Drawing.GetResourceObject( "PositionLabel/PointerLatLon" );
   PositionObject.SetSResource( null, "" );

   // Set US zooming message to OFF initially.
   Drawing.SetDResource( "Map/USZoomingMessage/Visibility", 0.0 );
}

//////////////////////////////////////////////////////////////////////////
// Creates NodeGroup to hold airport icons and adds the icons to it.
//////////////////////////////////////////////////////////////////////////
function CreateAirportIcons( /* int */ map )
{
   NodeGroup[ map ] =
     GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                       GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   NodeGroup[ map ].SetSResource( "Name", "NodeGroup" );

   // Add city/node icons
   for( var i = 0; i < NumNodes; ++i )
     AddNode( NodeArray[ i ], map, i );

   /* Add the group to the GIS Object which will automatically manage 
      the GIS coordinate conversion. This allows to specify node 
      positions in lat/lon instead of the X/Y world coordinates.
   */
   GISObject[ map ].AddObjectToBottom( NodeGroup[ map ] );
}

//////////////////////////////////////////////////////////////////////////
// Creates PlaneGroup to hold plane icons and adds the icons to it.
//////////////////////////////////////////////////////////////////////////
function CreatePlaneIcons( /* int */ map )
{
   PlaneGroup[ map ] =
     GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                       GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   PlaneGroup[ map ].SetSResource( "Name", "PlaneGroup" );

   // Add plane icons
   for( var i=0; i < NumPlanes; ++i )
     AddPlane( PlaneArray[ i ], map, i );
   
   /* Add the group to the GIS Object which will automatically manage 
      the GIS coordinate conversion. This allows to specify plane 
      positions in lat/lon instead of the X/Y world coordinates.
   */
   GISObject[ map ].AddObjectToBottom( PlaneGroup[ map ] );
}

//////////////////////////////////////////////////////////////////////////
function AddNode( /* NodeData */ node_data, /* int */ map, /* int */ index )
{      
   // Create a copy of a node (GlgObject). */
   var node = NodeTemplate[ map ].CloneObject( GLG.GlgCloneType.STRONG_CLONE );
      
   node.SetSResource( "Name", node_data.name );  // Set object name

   /* Set node position in lat/lon coordinates. The GIS object will handle
      the GIS coordinate conversion depending on the map the node icon is 
      displayed in, as well as the map's zoom and pan state.
   */
   node.SetGResource( "Position", 
                      node_data.lat_lon.x, node_data.lat_lon.y, 0.0 );

   // Index for direct access
   node.SetDResource( "DataIndex", index );

   if( map == 1 )        // On the detailed map, show node name label.
     node.SetSResource( "LabelString", node_data.name );
      
   var tooltip;
   if( map == 0 )   // On the thumbnail map, show node name in the tooltip.
     tooltip = node_data.name;
   else   // On the detailed map, include lat/lon into the tooltip.
     tooltip = node_data.name + ", " + CreateLocationString( node_data.lat_lon );
   node.SetSResource( "TooltipString", tooltip );
        
   node_data.graphics[ map ] = node;

   // Add the node to the requested map (thumbnail or detailed).
   NodeGroup[ map ].AddObjectToBottom( node );
}

//////////////////////////////////////////////////////////////////////////
// Adds a plane icon, fills labels, tooltips, etc.
//////////////////////////////////////////////////////////////////////////
function AddPlane( /* PlaneData */ plane_data, /* int */ map, /* int */ index )
{
   // Create a copy of a plane (GlgObject).
   var plane = PlaneTemplate[ map ].CloneObject( GLG.GlgCloneType.STRONG_CLONE );
   
   plane.SetSResource( "Name", plane_data.name );      // Object name
   
   // Index for direct access
   plane.SetDResource( "DataIndex", index );
   
   plane_data.graphics[ map ] = plane;
   
   // Check if the icon has an angle to indicate its direction.
   if( plane.GetResourceObject( "Angle" ) != null )
     plane_data.has_angle[ map ] = true;
   
   /* The plane will be positioned with PositionPlane() after the GIS object
      have been setup and the plane's lat/lon has been calculated by the 
      flight simulation. */

   // Add the plane to the requested map (thumbnail or detailed).
   PlaneGroup[ map ].AddObjectToBottom( plane );
}

//////////////////////////////////////////////////////////////////////////
function PositionPlane( /* PlaneData */ plane, /* int */ map )
{
   if( plane.graphics[ map ] == null || 
       plane.from_node == null || plane.to_node == null )
     return;
   
   // Obtain the plane's current position.
   GetPlaneLatLon( plane );

   /* Update plane's icon in the drawing by setting its lat/lon coordinates.
      The GIS object will handle the GIS coordinate conversion depending on 
      the map the plane icon is displayed in, as well as the map's zoom 
      and pan state.
   */
   plane.graphics[ map ].
     SetGResource( "Position", plane.lat_lon.x, plane.lat_lon.y, 0.0 );

   // Update icon's direction angle is necessary
   if( plane.has_angle[ map ] )
   {
      var angle = GetPlaneAngle( plane, map );   /* double  */
      plane.graphics[ map ].SetDResource( "Angle", angle );
   }
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Converts plane lat/lon to the GLG world 
//     coordinates for calculating plane speed and directional angle.
//////////////////////////////////////////////////////////////////////////
function GetPlanePosition( /* PlaneData */ plane, /* int */ map,
                           /* GlgPoint */ xyz )
{
   // Converts lat/lon to X/Y using GIS object's current projection.
   GISObject[ map ].GISConvert( null, GLG.GlgCoordType.OBJECT_COORD, 
                                 /* Lat/Lon to XY */ false, plane.lat_lon, xyz );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Converts node lat/lon to the GLG world 
//     coordinates for calculating plane's initial directional angle.
//////////////////////////////////////////////////////////////////////////
function GetNodePosition( /* NodeData */ node, /* int */ map,
                          /* GlgPoint */ xyz )
{
   // Converts lat/lon to X/Y using GIS object's current projection.
   GISObject[ map ].GISConvert( null, GLG.GlgCoordType.OBJECT_COORD, 
                                /* Lat/Lon to XY */ false, node.lat_lon, xyz );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates plane icon's directional angle.
//     In an application, it will query the plane's directional angle.
//////////////////////////////////////////////////////////////////////////
function GetPlaneAngle( /* PlaneData */ plane, /* int */ map )  /* double */
{
   /* Rectangular projection preserves straight lines, we can use the 
      angle of the line connecting the start and end nodes. For the
      orthographic projection, use this case if the plane has just started
      and there is no previous position stored.
   */
   if( MapProjection[ map ] == GLG.GlgProjectionType.RECTANGULAR_PROJECTION ||
       plane.path_position == plane.path_position_last )   // Just started
   {
      GetNodePosition( plane.from_node, map, last_xyz );
      GetNodePosition( plane.to_node, map, curr_xyz );
   }
   else  /* In the orthographic projection straight lines are drawn as 
            curves. Use the angle of the line connecting the current and 
            last position of the plane. */
   {
      var stored_position;   /* double */
      
      stored_position = plane.path_position;    // Store current position.
      
      // Get coordinates of the plane's previous position
      plane.path_position = plane.path_position_last;
      GetPlaneLatLon( plane );
      GetPlanePosition( plane, map, last_xyz );
      
      // Restore the plane's current position and get its coordinates.
      plane.path_position = stored_position;
      GetPlaneLatLon( plane );
      GetPlanePosition( plane, map, curr_xyz );
   }

   /* Calculate the angle of a line connecting the previous and 
      current position.
   */
   return GetAngle( last_xyz, curr_xyz );
}

//////////////////////////////////////////////////////////////////////////
// Checks if the object is visible in the current zoom region.
// This prevents wrap-around errors under big zoom factors.
//////////////////////////////////////////////////////////////////////////
function GetVisibility( /* GlgPoint */ position, /* double */ adj ) /* boolean */
{
   // Use adj as a gap
   return ( position.x > -1000.0 * adj && position.x < 1000.0 * adj &&
            position.y > -1000.0 * adj && position.y < 1000.0 * adj );
}

//////////////////////////////////////////////////////////////////////////
function SetMapLoading( /* int */ map, /* boolean */ show )
{
   Map[ map ].SetDResource( "LoadingMessage/Visibility", show ? 1 : 0 );
   MapLoaded[ map ] = !show;  // Set to false when the message is displayed.
}

//////////////////////////////////////////////////////////////////////////
// Updates plane positions on both maps.
//////////////////////////////////////////////////////////////////////////
function UpdatePlanes()
{
   var i;
   
   for( i=0; i<2; ++i )
     if( !MapLoaded[ i ] &&
         Math.trunc( GISObject[ i ].GetDResource( "ImageLoaded" ) ) != 0 )
       SetMapLoading( i, false );
   
   if( PerformUpdates )
   {
      for( i = 0; i < NumPlanes; ++i )
        UpdatePlane( PlaneArray[ i ] );
      
      UpdateSelectedPlaneStatus();
      
      if( LockSelectedPlane )
        UpdateLocking();
      
      Drawing.Update();
   }
   
   // Restart the update timer
   timer = setTimeout( UpdatePlanes, UpdateInterval );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates new plane position using a
//     flight simulation. In an application, the real plane position 
//     will be queried here.
//////////////////////////////////////////////////////////////////////////
function UpdatePlane( /* PlaneData */ plane )
{      
   if( plane.graphics == null ||
       plane.from_node == null || plane.to_node == null )
     return;
   
   if( plane.path_position == 1.0 )
     StartPlane( plane, false );     // Finished old path, start a new one. 
   else
   {
      var speed = PlaneSpeed;   /* double */
      
      /* Slow the selected plane down when zoomed on it for a nice
         demo effect.
      */
      if( plane == SelectedPlane && LockSelectedPlane )
      {
         GetPlanePosition( plane, 1, old_position );
         
         // Store the current path position.
         var stored_position = plane.path_position;   /* double */

         plane.path_position += plane.speed * speed;    // Increment it
         
         GetPlanePosition( plane, 1, new_position );
         
         // Distance between the old and current position of the plane
         var dist = GetLength( old_position, new_position );   /* double */

         // Adjust the plane's speed to slow it down if the distance is too big.
         if( dist > MaxZoomSpeed )
         {
            var slow_down = dist / MaxZoomSpeed;   /* double */
            speed /= slow_down;
         }

         // Restore the current path position.
         plane.path_position = stored_position;
      }
      
      /* Store last position for calculating the angle in the ORTHO 
         projection.
      */
      plane.path_position_last = plane.path_position;
      
      // Move the plane.
      plane.path_position += plane.speed * speed;
      if( plane.path_position > 1.0 )
        plane.path_position = 1.0; // Clamp to 1: can't go past the airport!
   }
   
   for( var i =0; i<2; ++i )
     PositionPlane( plane, i );    // Position the plane on both maps
}

//////////////////////////////////////////////////////////////////////////
// In the lock mode, pans the map to keep selected plane visible when the 
// plane moves out of the detailed map area.
//////////////////////////////////////////////////////////////////////////
function UpdateLocking()
{	 
   // Locking is in effect only on the detailed map.
   var map = 1;

   GetPlanePosition( SelectedPlane, map, position );
   
   /* If selected plane goes on another side of the globe or off the 
      visible portion of the map, pan the map to re-center on the 
      selected plane. The Z coordinate goes to zero when the plane gets 
      close to the globe's edge, and becomes negative on the invisible 
      side of the globe.
   */
   if( MapProjection[ map ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION &&
       position.z < 0.1 || !GetVisibility( position, 0.9 ) )
   {
      CenterOnPlane( SelectedPlane, 1 );
      UpdateMap( 1 );
      
      /* If the thumbnail map used orthographic projection, rotate the 
         thumbnail globe to keep the selected plane visible. In rectangular
         projection, the whole world is visible and no action is required.
      */
      if( MapProjection[ map ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
      {
         CenterOnPlane( SelectedPlane, 0 );
         UpdateMap( 0 );
      }
   }
}

//////////////////////////////////////////////////////////////////////////
// Updates the map image; also updates the selected region display on the
// thumbnail map.
//////////////////////////////////////////////////////////////////////////
function UpdateMap( /* int */ map )
{
   // Display the wait message while the new map image is being generated.
   SetMapLoading( map, true );
   
   /* Just setup, don't draw: will be done at the end by the caller
      after selected area, etc., was updated.
   */
   Map[ map ].SetupHierarchy();
   
   /* Adjust selected region on the thumbnail map to match the new 
      zoom area of the detailed map.
   */
   SetSelectedArea();
}

//////////////////////////////////////////////////////////////////////////
// Handle user interaction.
//////////////////////////////////////////////////////////////////////////
function InputCallback( /* GlgObject */ vp, /* GlgObject */ message_obj )
{
   var
     origin,
     format,
     action,
     subaction;
   
   origin = message_obj.GetSResource( "Origin" );
   format = message_obj.GetSResource( "Format" );
   action = message_obj.GetSResource( "Action" );
   subaction = message_obj.GetSResource( "SubAction" );

   // Handle window closing.
   if( format == "Window" )
   {
      if( action == "DeleteWindow" )
      {
         if( origin == "SelectionDialog" )
         {
            // Close selection dialog
            Drawing.SetDResource( "SelectionDialog/Visibility", 0.0 );
            Drawing.Update();	 
         }
         else if( origin == "TopMap" )
         {
            // Close top map window
            Drawing.SetDResource( "TopMap/Visibility", 0.0 );
            Drawing.Update();	 
         }
      }
      return;
   }
   
   if( format == "Button" )  // Handle button clicks
   {	 
      if( action != "Activate" )
        return;
      
      PanMode = false;    // Abort Pan mode
      
      // Abort ZoomTo/Drag modes (if any) on both maps.
      Map[ 0 ].SetZoom( null, 'e', 0.0 );
      Map[ 1 ].SetZoom( null, 'e', 0.0 );
      
      if( origin == "CloseDialog" )
      {
         Drawing.SetDResource( "SelectionDialog/Visibility", 0.0 );
         Drawing.Update();	 
      }
      else if( origin == "ToggleLock" )
      {
         SetLocking( !LockSelectedPlane );
         Drawing.Update();	 
      }
      else if( origin == "Up" )
      {	    
         Zoom( 'u', 0.0 );
         Drawing.Update();
      }
      else if( origin == "Down" )
      {	    
         Zoom( 'd', 0.0 );
         Drawing.Update();
      }
      else if( origin == "Left" )
      {	    
         Zoom( 'l', 0.0 );
         Drawing.Update();
      }
      else if( origin == "Right" )
      {	    
         Zoom( 'r', 0.0 );
         Drawing.Update();
      }
      else if( origin == "ZoomIn" )
      {
         Zoom( 'i', 2.0 );
         HandleZoomLevel();
         Drawing.Update();	 
      }
      else if( origin == "ZoomOut" )
      {
         Zoom( 'o', 2.0 );
         HandleZoomLevel();
         Drawing.Update();	 
      }
      else if( origin == "ZoomReset" )
      {	
         Zoom( 'n', 0.0 );
         HandleZoomLevel();
         Drawing.Update();	 
      }
      else if( origin == "ZoomTo" )
      {
         /* Temporarily enable touch events to make it possible to define
            the ZoomTo rectangle by touch dragging on mobile devices.
         */
         StartDragging = true;

         // Abort a possible Drag mode on thumbnail map.
         Map[ 0 ].SetZoom( null, 'e', 0.0 );
         
         // Start ZoomTo mode on the detailed map.
         Map[ 1 ].SetZoom( null, 't', 0.0 );
         SetStatus( "Define a rectangular area on the detailed map to zoom to." );
         SuspendPromptUpdates = true;
         Drawing.Update();	 
      }
      else if( origin == "Pan" )
      {	    
         PanMode = true;
         SetStatus( "Click to define a new center." );
         SuspendPromptUpdates = true;
         Drawing.Update();	 
      }
      else if( origin == "Drag" )
      {
         /* Activate dragging mode on both maps. Dragging will start on the
            mouse click. If no object of interest is selected by the mouse 
            click, the dragging will be started by the code in the Trace 
            callback anyway. The "Drag" button demonstrates an alternative 
            way to start dragging from a button.
         */
         Map[ 0 ].SetZoom( null, 's', 0.0 );
         Map[ 1 ].SetZoom( null, 's', 0.0 );
         SetStatus( "Click and drag the map with the mouse." );
         SuspendPromptUpdates = true;
         StartDragging = true;
         Drawing.Update();
      }
      else if( origin == "AirportLabels" )
      {
         CityLabels = !CityLabels;
         SetGISLayers( 1 );
         Drawing.Update();	 
      }
      else if( origin == "Planes" )
      {
         ToggleResource( Map[ 1 ], "PlaneGroup/Visibility" );
         Drawing.Update();	 
      }
      else if( origin == "ValueDisplay" )
      {
         // Visibility of all labels is constrained, set just one.
         ToggleResource( PlaneArray[ 0 ].graphics[ 1 ], "Label/Visibility" );
         Drawing.Update();
      }
      else if( origin == "ToggleStates" )
      {
         StateDisplay = !StateDisplay;
         SetGISLayers( 0 );    // Thumbnail map
         SetGISLayers( 1 );    // Detailed map 
         
         Drawing.Update();	 
      }
      else if( origin == "Update" )
      {
         PerformUpdates = !PerformUpdates;
         Drawing.Update();
      }	
      else if( origin == "PlaneSize" )
      {
         // Change plane icon's size.
         if( PlaneSize == SMALL_SIZE )
           PlaneSize = MEDIUM_SIZE;
         else if( PlaneSize == MEDIUM_SIZE )
           PlaneSize = BIG_SIZE;
         else // BIG_SIZE
           PlaneSize = SMALL_SIZE;	 
         
         SetPlaneSize();
         Drawing.Update();	 
      }	
   }
   /* Process mouse clicks on plane icons, implemented as an Action with
      the Plane label attached to an icon and activated on a mouse click. 
   */
   else if( format == "CustomEvent" )
   {
      if( StartDragging )
        return;  // Ignore selection in the Dragging mode.
      
      var event_label = message_obj.GetSResource( "EventLabel" );   /* String */
      
      if( event_label == "Plane" )
      {
         /* Map dragging mode is activated on a mouse click in the trace 
            callback. Abort the dragging mode if an object with custom event
            was selected. This gives custom events a higher priority compared 
            to the dragging mode. If it's a ZoomTo mode activated by a button,
            don't abort and ignore the object selection.
         */
         var zoom_mode = ZoomToMode();   /* int */
         if( zoom_mode == 0 ||
             ( zoom_mode & GLG.GlgZoomState.PAN_DRAG_STATE ) != 0 )
         {
            if( zoom_mode != 0 )
              Map[1].SetZoom( null, 'e', 0.0 );  /* Abort zoom mode */
            
            var data_index =  /* int */
              Math.trunc( message_obj.GetDResource( "Object/DataIndex" ) );
            
            if( SelectedPlane != PlaneArray[ data_index ] )
            {
               SelectPlane( SelectedPlane, 0 );  // Unhighlight old
               SelectedPlane = PlaneArray[ data_index ];
               SelectPlane( SelectedPlane, 1 );  // Highlight new 
               Drawing.Update();
            }
         }
      }
   }
   else if( action == "Zoom" )
   {
      // Disable locking: we may be zooming on a different area.
      SetLocking( false );
      
      if( subaction == "Start" )   // Starting ZoomTo
      {
         SuspendPromptUpdates = true;
      }
      else if( subaction == "ZoomRectangle" )
      {
         /* ZoomTo rectangle created - set a custom distinct color
            good for colors at all zoom levels.
         */
         var zoom_rect =   /* GlgObject */
           Map[1].GetResourceObject( "GlgZoomRect" );
         zoom_rect.SetGResource( "EdgeColor", 1.0, 0.0, 0.0 );
      }
      else if( subaction == "End" )   // Finishing ZoomTo
      {
         /* Rotate the thumbnail globe to show the same area as the 
            detailed map.
         */
         SyncGlobeWithDetailedMap( origin );
            
         HandleZoomLevel();
         SuspendPromptUpdates = false;
         Drawing.Update();
      }
      // Aborting ZoomTo (right mouse button, etc.).
      else if( subaction == "Abort" )
      {
         SuspendPromptUpdates = false;
      }
   }
   else if( action == "Pan" )
   {
      // Disable locking when scrolling the map with the mouse.
      SetLocking( false );
      
      // Starting dragging with the mouse
      if( subaction == "Start" )    // Map dragging start
      {
         SetStatus( "Drag the map with the mouse." );
         SuspendPromptUpdates = true;
         Drawing.Update();
      }
      else if( subaction == "Drag" ||         // Dragging
               subaction == "ValueChanged" )   // Scrollbars
      {
         /* When dragging the detailed map with the mouse, rotate the 
            thumbnail globe to show the same area as the detailed map.
         */
         SyncGlobeWithDetailedMap( origin );
         Drawing.Update();
      }
      else if( subaction == "End" )      // Map dragging end
      {
         SuspendPromptUpdates = false;
         SetStatus( "" );   // Reset prompt when done dragging.
         
         /* Reset dragging mode on both maps, in case it was started 
            with the Drag button.
         */
         Map[ 0 ].SetZoom( null, 'e', 0.0 );
         Map[ 1 ].SetZoom( null, 'e', 0.0 );
         Drawing.Update();         
      }
      // Dragging aborted (right mouse button, etc.).
      else if( subaction == "Abort" )
      {
         SuspendPromptUpdates = false;
         SetStatus( "" );   // Reset prompt when aborting dragging.
         Drawing.Update();         
      }
   }
}

//////////////////////////////////////////////////////////////////////////
function ZoomToMode()   /* int */
{
   // Check if the detailed map is in the ZoomTo mode.
   return Math.trunc( Map[ 1 ].GetDResource( "ZoomToMode" ) );
}

//////////////////////////////////////////////////////////////////////////
function Zoom( /* String */ type, /* double */ value )
{
   switch( type )
   {
    default:
      Map[ 1 ].SetZoom( null, type, value );
      CheckScrollLimits( type );
      UpdateMap( 1 );

      /* Sync thumbnail map when panning. After "1:1" zoom reset, the maps' 
         centers may differ, sync the thumbnail map when zooming in the 
         first time.
      */
      switch( type )
      {
       case 'i':
         SyncGlobeWithDetailedMap( null );
         break;
       case 'u':
       case 'd':
       case 'l':
       case 'r':
         SyncGlobeWithDetailedMap( null );
         break;
      }
      break;
      
    case 'n':
      if( MapProjection[ 0 ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
      {
         // Reset thumbnail globe to initial position.
         GISObject[ 0 ].SetGResourceFromPoint( "GISCenter", InitCenter[0] );
         GISObject[ 0 ].SetGResourceFromPoint( "GISExtent", InitExtent[0] );
         
         UpdateMap( 0 );
      }
      
      // Reset detailed map to initial extent.
      GISObject[ 1 ].SetGResourceFromPoint( "GISCenter", InitCenter[1] );
      GISObject[ 1 ].SetGResourceFromPoint( "GISExtent", InitExtent[1] );
      UpdateMap( 1 );
      
      // Make selected area rectangle invisible when no zoom
      GISObject[ 0 ].SetDResource( "GISArray/SelectedArea/Visibility", 0.0 );
      break;
   }
}

//////////////////////////////////////////////////////////////////////////
// For rectangular projection on the detailed map, make sure the map 
// does not scroll beyond the poles in the vertical direction.
//////////////////////////////////////////////////////////////////////////
function CheckScrollLimits( /* String */ type )
{
   var extent, center;      /* GlgPoint */
   var min_y, max_y;        /* double  */
   var adjust_x, adjust_y;  /* boolean */
      
   if( MapProjection[ 1 ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
     return;   // Allow unlimited scrolling on ortho.
   
   switch( type )
   {
    case 'u':  // Scroll up
    case 'd':  // Scroll down
    case 'l':  // Scroll left
    case 'r':  // Scroll right
      break; // Adjust only for scroll types.
    default: return;   // Don't adjust for other zoom types.
   }
   
   extent = GISObject[ 1 ].GetGResource( "GISExtent" );
   center = GISObject[ 1 ].GetGResource( "GISCenter" );
   
   min_y = center.y - extent.y / 2.0;
   max_y = center.y + extent.y / 2.0;
   
   /* Check and adjust center lat to make sure the map does not scroll 
      beyond the poles in the vertical direction. 
   */
   adjust_y = true;
   if( extent.y >= 180.0 )
     center.y = 0.0;
   else if( min_y < -90.0 )
     center.y = -90.0 + extent.y / 2.0;
   else if( max_y > 90.0 )
     center.y = 90.0 - extent.y / 2.0;
   else
     adjust_y = false;
   
   /* Allow scrolling tp +-180 in horizontal direction, to match the
      range of the horizontal scrollbar.
   */
   adjust_x = true;
   if( center.x < -180.0 )
     center.x = -180.0;
   else if( center.x > 180.0 )
     center.x = 180.0;
   else
     adjust_x = false;
   
   // Set adjusted center
   if( adjust_x || adjust_y )
     GISObject[ 1 ].SetGResourceFromPoint( "GISCenter", center );
}

//////////////////////////////////////////////////////////////////////////
// Rotates the globe on the thumbnail map to show the same place as the
// detailed map.
//////////////////////////////////////////////////////////////////////////
function SyncGlobeWithDetailedMap( /* String */ origin )
{
   var center, globe_center;   /* GlgPoint */
      
   // Update the detailed map, unless it's thumbnail map dragging.
   if( origin != "TopMap" )
     UpdateMap( 1 );
   
   /* Sync up only if the detailed map (origin == "Map") is rotated, 
      not the thumbnail map (origin == "TopMap").
   */
   if( origin != null && origin == "Map" )
   {
      // Get the center of the detailed map.
      center = GISObject[ 1 ].GetGResource( "GISCenter" );
      
      // Get the center of the thumbnail globe.
      globe_center = GISObject[ 0 ].GetGResource( "GISCenter" );
      
      // Sync up if centers differ.
      if( globe_center.x != center.x || globe_center.y != center.y ||
          globe_center.z != center.z )
      {
         // Rotate the thumbnail globe to show the same area.
         GISObject[ 0 ].SetGResourceFromPoint( "GISCenter", center );
         
         UpdateMap( 0 );
      }
   }
   else
     /* Don't sync when the globe on the thumbnail map is rotated
        (origin == "TopMap"), to allow moving it separately. Just
        update the selected area display.
     */
     UpdateMap( 0 );
}

//////////////////////////////////////////////////////////////////////////
function EnableTouchDragging()
{
   if( EnableTouchDragging.first_time == undefined )   // first time
   {
       alert( "Scrolling the map by touch-dragging is disabled on this page by default to avoid interfering with page scrolling and zooming on mobile devices. Use the Mobile Version button to see the mobile version with touch scrolling enabled by default.\n\nTo scroll the map on mobile devices by touch on this page, press the Enable Touch Dragging button, then touch and drag the map. To repeat, press the button again." );
      EnableTouchDragging.first_time = false;
   }
   
   StartDragging = true;
}

//////////////////////////////////////////////////////////////////////////
// Used to obtain coordinates of the mouse click. 
//////////////////////////////////////////////////////////////////////////
function TraceCallback( /* GlgObject */ viewport, /* GlgTraceData */ trace_info )
{      
   var map;   /* int */
   
   var event_type = trace_info.event_type;

   // Use the Map area events only.
   if( trace_info.viewport.Equals( Map[ 0 ] ) )
     map = 0;
   else if( trace_info.viewport.Equals( Map[ 1 ] ) )
     map = 1;
   else
   {
      /* Erase the current postion display when the mouse moves outside 
         of the map.
      */
      switch( event_type )
      {
       case GLG.GlgEventType.MOUSE_MOVED:
         PositionObject.SetSResource( null, "" );
         PositionArea.Update();
         break;
      }
      return;
   }

   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
      /* Enable touch dragging only for the mobile version to avoid 
         interfering with page scrolling and zooming.
      */
      if( !MobileVersion && !StartDragging )
         return;
      
      GLG.SetTouchMode();        /* Start dragging via touch events. */
      StartDragging = false;     /* Reset for the next time. */
      /* Fall through */

    case GLG.GlgEventType.TOUCH_MOVED:
      if( !GLG.GetTouchMode() )
        return;
    case GLG.GlgEventType.MOUSE_PRESSED:
    case GLG.GlgEventType.MOUSE_MOVED:
     point.x = trace_info.mouse_x * CoordScale;
     point.y = trace_info.mouse_y * CoordScale;
     point.z = 0.0;
     
      /* COORD_MAPPING_ADJ is added to the cursor coordinates for precise
         pixel mapping.
      */
      point.x += GLG.COORD_MAPPING_ADJ;
      point.y += GLG.COORD_MAPPING_ADJ;
      break;
        
    case GLG.GlgEventType.TOUCH_END:
    case GLG.GlgEventType.TOUCH_CANCEL:
    case GLG.GlgEventType.MOUSE_RELEASED:
      StartDragging = false;
      break;

    default: return;
   }

   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_MOVED:
    case GLG.GlgEventType.MOUSE_MOVED: 
      // Report lat/lon position under the mouse.

      /* Converts X/Y to lat/lon using GIS object's current projection,
         handles both maps.
      */
      GISObject[ map ].GISConvert( null, GLG.GlgCoordType.SCREEN_COORD,
                                   /* X/Y to Lat/Lon */ true, point, lat_lon );
      
      PositionObject.SetSResource( null, CreateLocationString( lat_lon ) );
      PositionArea.Update();
      break;
      
    case GLG.GlgEventType.TOUCH_START:
    case GLG.GlgEventType.MOUSE_PRESSED:
      if( ZoomToMode() != 0 )
        return; // ZoomTo or dragging mode in progress: pass it through.
      
      // Handle paning: set the new map center to the location of the click.
      if( PanMode )
      {
         if( trace_info.button != 1 )
           return;  // Use only the left button clicks.
         
         PanMode = false;
         
         /* Converts X/Y to lat/lon using GIS object's current projection,
            handles clicks on either map.
         */
         GISObject[ map ].GISConvert( null, GLG.GlgCoordType.SCREEN_COORD,
                                      /* X/Y to Lat/Lon */ true,
                                      point, lat_lon );
         
         if( MapProjection[ 0 ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
         {
            /* For the orthographic projection, Pan/Rotate the globe on the 
               thumbnail map as well. Don't do anything for the rectangular 
               projection: the whole world is already displayed.
            */
            GISObject[ 0 ].SetGResourceFromPoint( "GISCenter", lat_lon );
            UpdateMap( 0 );
            Map[ 0 ].Update();
         }
         
         // Pan the detailed map.
         GISObject[ 1 ].SetGResourceFromPoint( "GISCenter", lat_lon );
         UpdateMap( 1 );
         
         // Disable locking: we scrolled the map to see a different area.
         SetLocking( false );
         Drawing.Update();
      }
      else
        /* Not a pan mode: start dragging the map with the mouse. */
        Map[ map ].SetZoom( null, 's', 0.0 );
      break;
      
    default: return;
   }      
}

//////////////////////////////////////////////////////////////////////////
// Adjust selected region on the thumbnail map to match detailed map.
//////////////////////////////////////////////////////////////////////////
function SetSelectedArea()
{
   // Set the coordinates of the SelectedArea polygon.
   var rect =   /* GlgObject  */
     GISObject[ 0 ].GetResourceObject( "GISArray/SelectedArea" );
      
   var extent = GetExtentDegrees( 1 );   /* GlgPoint */

   if( extent.x >= 120.0 )
   {
      // Big area: don't need to show.
      rect.SetDResource( "Visibility", 0.0 );
   }
   else
   {
      rect.SetDResource( "Visibility", 1.0 );
      
      /*  Get lat/lon of the visible area of the detailed map. 
          Use 16 points for better precision, since the area is not 
          rectangular in the orthographic projection used for the thumbnail 
          globe.
      */
      var lat_lon = new Array( 16 );   /* GlgPoint[] */
      lat_lon[ 0  ] = GetLatLon( -1000.0, -1000.0, 1 );
      lat_lon[ 1  ] = GetLatLon( -1000.0,  -500.0, 1 );
      lat_lon[ 2  ] = GetLatLon( -1000.0,     0.0, 1 );
      lat_lon[ 3  ] = GetLatLon( -1000.0,   500.0, 1 );
      lat_lon[ 4  ] = GetLatLon( -1000.0,  1000.0, 1 );
      lat_lon[ 5  ] = GetLatLon(  -500.0,  1000.0, 1 );
      lat_lon[ 6  ] = GetLatLon(     0.0,  1000.0, 1 );
      lat_lon[ 7  ] = GetLatLon(   500.0,  1000.0, 1 );
      lat_lon[ 8  ] = GetLatLon(  1000.0,  1000.0, 1 );
      lat_lon[ 9  ] = GetLatLon(  1000.0,   500.0, 1 );
      lat_lon[ 10 ] = GetLatLon(  1000.0,     0.0, 1 );
      lat_lon[ 11 ] = GetLatLon(  1000.0,  -500.0, 1 );
      lat_lon[ 12 ] = GetLatLon(  1000.0, -1000.0, 1 );
      lat_lon[ 13 ] = GetLatLon(   500.0, -1000.0, 1 );
      lat_lon[ 14 ] = GetLatLon(     0.0, -1000.0, 1 );
      lat_lon[ 15 ] = GetLatLon(  -500.0, -1000.0, 1 );
      
      for( var i=0; i<16; ++i )
      {
         // Get polygon's points
         var point_obj = rect.GetElement( i );   /* GlgObject */
         
         // Set point's lat/lon
         point_obj.SetGResourceFromPoint( null, lat_lon[ i ] );
      }
   }
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Starts simulation for a plane, 
//     assigns its start and end nodes.
//////////////////////////////////////////////////////////////////////////
function StartPlane( /* PlaneData */ plane, /* boolean */ init )
{
   if( NumNodes < 2 )
   {
      GlgDemoError("Less then two nodes: can't start planes.");
      return;
   }
   
   var to_index, from_index;   /* int */
   from_index = Math.trunc( GLG.Rand( 0, NumNodes - 0.001 ) );
   do
   {
      to_index = Math.trunc( GLG.Rand( 0, NumNodes - 0.001 ) );
   } while( to_index == from_index );

   plane.from_node = NodeArray[ from_index ];
   plane.to_node = NodeArray[ to_index ];
   plane.flight_number = Math.trunc( GLG.Rand( 101.0, 1999.0 ) );
   plane.speed = GLG.Rand( 0.4, 1.0 );   // Vary plane speed

   if( init )
   {
      plane.path_position = GLG.Rand( 0.1, 0.2 );
      plane.path_position_last = plane.path_position - 0.05;  // For angle
   }
   else
   {
      plane.path_position = 0.0;
      plane.path_position_last = 0.0;
   }
   
   plane.tooltip[ 0 ] = "Flight " + plane.flight_number;
   
   // On the detailed map, add from/to node info to the tooltip.
   plane.tooltip[ 1 ] = plane.tooltip[ 0 ] +
     " from " + plane.from_node.name + " to " + plane.to_node.name;
   
   // Set the tooltip
   for( var i = 0; i < 2; ++i )      
     plane.graphics[ i ].SetSResource( "TooltipString", plane.tooltip[ i ] );

   // On detailed map[1], show the flight number as icon label
   plane.graphics[1].SetSResource( "LabelString",
                                   "Flight " + plane.flight_number );

   // Stop tracking the selected flight when it reaches destination.
   if( plane == SelectedPlane )
     SetLocking( false );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates plane's lat/lon using simulated 
//     data. In an application, it will query the current plane position.
//
// The simulation moves the plane from the start to the end node/city
// as controlled by the path_position parameter. The path_position changes
// in the range from from 0 (start node) to 1 (end node).
//////////////////////////////////////////////////////////////////////////
function GetPlaneLatLon( /* PlaneData */ plane )
{
   plane.lat_lon.x = RELATIVE_TO_NEW_RANGE( plane.from_node.lat_lon.x, 
                                            plane.to_node.lat_lon.x,
                                            plane.path_position );
   
   plane.lat_lon.y = RELATIVE_TO_NEW_RANGE( plane.from_node.lat_lon.y, 
                                            plane.to_node.lat_lon.y,
                                            plane.path_position );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Select some plane on the initial appearance.
//////////////////////////////////////////////////////////////////////////
function InitSelection()
{
   // Select the first plane
   SelectedPlane = PlaneArray[ 0 ];
   SelectPlane( SelectedPlane, 1 );
   
   // Lock on the selected plane, pan the map to keep it visible.
   SetLocking( true );

   // Rotate thumbnail globe too to show the same location.
   if( MapProjection[ 0 ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
     GISObject[ 0 ].SetGResource( "GISCenter", -95.35, 37.37, 0.0 );
}

//////////////////////////////////////////////////////////////////////////
// UTILITY FUNCTION: Calculates an angle between the line defined by two 
// points and the X axis.
//////////////////////////////////////////////////////////////////////////
function GetAngle( /* GlgPoint */ pt1, /* GlgPoint */ pt2 )   /* double */
{
   var length, angle;   /* double */
      
   length = GetLength( pt1, pt2 );
   
   if( length == 0.0 )
     angle = 0.0;
   else
   {
      angle = Math.acos( ( pt2.x - pt1.x ) / length );
      
      if( pt2.y - pt1.y < 0.0 )  // ScreenSpace Z axis points to the user.
        angle = - angle;
   }
   
   return RadToDeg( angle );
}

//////////////////////////////////////////////////////////////////////////
// UTILITY FUNCTION: Calculates a distance between two points in 2D.
//////////////////////////////////////////////////////////////////////////
function GetLength( /* GlgPoint */ pt1, /* GlgPoint */ pt2 )   /* double */
{
   return Math.sqrt( ( pt2.x - pt1.x ) * ( pt2.x - pt1.x ) +
                     ( pt2.y - pt1.y ) * ( pt2.y - pt1.y ) );
}

//////////////////////////////////////////////////////////////////////////
// Turns plane icons' labels ON or OFF on the detailed map.
//////////////////////////////////////////////////////////////////////////
function SetPlaneLabels( /* boolean */ on )
{
   var label =    /* GlgObject */
     PlaneArray[ 0 ].graphics[ 1 ].GetResourceObject( "Label" );
   if( label != null )
     label.SetDResource( "Visibility", on ? 1.0 : 0.0 );
}

//////////////////////////////////////////////////////////////////////////
// Sets locking mode ON or OFF. If locking is ON, the map is automatically
// scrolled to keep the selected plane icon in view.
//////////////////////////////////////////////////////////////////////////
function SetLocking( /* boolean */ lock_state )
{
   LockSelectedPlane = lock_state;
}

//////////////////////////////////////////////////////////////////////////
// Displays the selected plane's location and locking status.
//////////////////////////////////////////////////////////////////////////
function UpdateSelectedPlaneStatus()
{
   var message;   /* String */

   if( SuspendPromptUpdates )
     return;
   
   if( SelectedPlane != null )
   {
      GetPlaneLatLon( SelectedPlane );
      
      if( LockSelectedPlane )
        message = "Map is locked on selected Flight " + 
          SelectedPlane.flight_number + ", " + 
          CreateLocationString( SelectedPlane.lat_lon );
      else
        message = "Selected Flight " +  SelectedPlane.flight_number +
          ", " + CreateLocationString( SelectedPlane.lat_lon );
   }
   else
     message = "Click on the plane icon to select.";
   Drawing.SetSResource( "StatusLabel/String", message );
}

//////////////////////////////////////////////////////////////////////////
// Displays a message in the status area.
//////////////////////////////////////////////////////////////////////////
function SetStatus( /* String */ message )
{
   Drawing.SetSResource( "StatusLabel/String", message );
   Drawing.GetResourceObject( "StatusArea" ).Update();
}

//////////////////////////////////////////////////////////////////////////
// Centers the map on the selected plane, used when locking mode is ON.
//////////////////////////////////////////////////////////////////////////
function CenterOnPlane( /* PlaneData */ plane, /* int */ map )
{      
   // Center the map on the plane
   GISObject[ map ].SetGResourceFromPoint( "GISCenter", plane.lat_lon );
}

//////////////////////////////////////////////////////////////////////////
// Highlights the selected plane on both maps by changing its 
// SelectedIndex value.
//////////////////////////////////////////////////////////////////////////
function SelectPlane( /* PlaneData */ plane, /* int */ selected )
{
   for( var i=0; i < 2; ++i )
     if( plane.graphics[ i ] != null )
       plane.graphics[ i ].SetDResource( "SelectedIndex", selected );
}

//////////////////////////////////////////////////////////////////////////
function SetPlaneSize()
{
   for( var i=0; i<2; ++i )
   {
      var resource =   /* GlgObject */
        PlaneTemplate[ i ].GetResourceObject( "IconScale" );
      if( resource != null )
        resource.SetDResource( null, PlaneSize );
   }
}

//////////////////////////////////////////////////////////////////////////
// Toggle resource between 0 and 1.
//////////////////////////////////////////////////////////////////////////
function ToggleResource( /* GlgObject */ glg_object, /* String */ res_name )
{
   var value = glg_object.GetDResource( res_name );  /* double */
   glg_object.SetDResource( res_name, value != 0.0 ? 0.0 : 1.0 );
}

const CITY_ON_1    = ",cities_100K,cities_500K,cities_1M,cities_3M,cities_6M";
const CITY_OFF_1   = ",-cities_100K,-cities_500K,-cities_1M,-cities_3M,-cities_6M";
const STATES_ON_1  = ",states";
const STATES_OFF_1 = ",-bnd_polbndl_intern,-bnd_polbndl_prim,-states";

const CITY_ON_2    = ",us_cities";
const CITY_OFF_2   = ",-us_cities";
const STATES_ON_2  = ",states";
const STATES_OFF_2 = ",-states";

////////////////////////////////////////////////////////////////////////
// Toggle map layers: airport/city labels and states.
////////////////////////////////////////////////////////////////////////
function SetGISLayers( /* int */ map )
{
   var layers;   /* String */

   var CITY_ON, CITY_OFF, STATES_ON, STATES_OFF;    /* STring */
   if( !SuppliedMapServerURL )
   {
      CITY_ON = CITY_ON_1;
      CITY_OFF = CITY_OFF_1;
      STATES_ON = STATES_ON_1;
      STATES_OFF = STATES_OFF_1;
   }
   else
   {
      CITY_ON = CITY_ON_2;
      CITY_OFF = CITY_OFF_2;
      STATES_ON = STATES_ON_2;
      STATES_OFF = STATES_OFF_2;
   }
   
   // Airport labels should be visible only when city labels are off.
   NodeTemplate[1].SetDResource( "Label/Visibility", CityLabels ? 0.0 : 1.0 );
   
   layers = "default_gis";
   
   // Add city layers if they are on on the detailed map.
   if( map == 1 )
     if( CityLabels )
       layers = layers + CITY_ON;
     else
       layers = layers + CITY_OFF;
   
   if( StateDisplay )   // Add states layer if it is on.
     // Enable states regardless of the default.
     layers = layers + STATES_ON;
   else
     // Disable state outline display.
     layers = layers + STATES_OFF;
   
   GISObject[ map ].SetSResource( "GISLayers", layers );
}

////////////////////////////////////////////////////////////////////////
// Convenience wrapper
////////////////////////////////////////////////////////////////////////
function GetLatLon( /* double */ x, /* double */ y, /* int */ map )   /* GlgPoint */
{
   var lat_lon = GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

   util_point.x = x;
   util_point.y = y;
   util_point.z = 0.0;
   GISObject[ map ].GISConvert( null, GLG.GlgCoordType.OBJECT_COORD,
                                /* X/Y to Lat/Lon */ true, util_point, lat_lon );
   return lat_lon;
}

//////////////////////////////////////////////////////////////////////////
function RELATIVE_TO_NEW_RANGE( /* double */ low, /* double */ high,
                                /* double */ rel_value )   /* double */
{
   return ( low + ( high - low ) * rel_value );
}

//////////////////////////////////////////////////////////////////////////
function VALUE_TO_RELATIVE( /* double */ low, /* double */ high,
                            /* double */ value )   /* double */
{
   return ( high - low != 0.0 ? ( value - low ) / ( high - low ) : 0.0 );
}

//////////////////////////////////////////////////////////////////////////
function DegToRad( /* double */ angle )   /* double */
{
   return angle / 180.0 * Math.PI;
}

//////////////////////////////////////////////////////////////////////////
function RadToDeg( /* double */ angle )   /* double */
{
   return angle / Math.PI * 180.0;
}

//////////////////////////////////////////////////////////////////////////
// Turn airport and plane labels on or off depending on the zoom level and
// adjust plane icon size. 
//////////////////////////////////////////////////////////////////////////
function HandleZoomLevel()
{
   var extent;     /* GlgPoint */
   var high_zoom;  /* boolean */
      
   extent = GetExtentDegrees( 1 );
   
   high_zoom = ( extent.x < 100.0 && extent.y < 50.0 );
   
   SetPlaneLabels( high_zoom );     // Plane labels.
   
   CityLabels = true;
   SetGISLayers( 1 );     // Airport labels.
   
   // Plane icons size.
   PlaneSize = ( high_zoom ? MEDIUM_SIZE : SMALL_SIZE );
   SetPlaneSize();
}

//////////////////////////////////////////////////////////////////////////
// Gets extent in lat/lon.
// For the ortho projection, roughly converts from meters to lat/lon.
//////////////////////////////////////////////////////////////////////////
function GetExtentDegrees( /* int */ map )   /* GlgPoint */
{   
   var extent = GISObject[ map ].GetGResource( "GISExtent" );   /* GlgPoint */
   if( MapProjection[ map ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
   {
      extent.x = extent.x / GLG.EQUATOR_RADIUS * 90.0;
      extent.y = extent.y / GLG.POLAR_RADIUS * 90.0;
   }
   return extent;
}

//////////////////////////////////////////////////////////////////////////
// Generate a location info string by converting +- sign info into the
// N/S, E/W suffixes, and decimal fraction to deg, min, sec.
//////////////////////////////////////////////////////////////////////////
function CreateLocationString( /* GlgPoint */ point )   /* String */
{
   var  /* int */
     x_deg, y_deg,
     x_min, y_min,
     x_sec, y_sec;
   var  /* String */
        char_x,
        char_y;
   var lat, lon;  /* double */

   if( point.z < 0.0 )
     return "";

   lon = point.x;
   lat = point.y;
   
   if( lon < 0.0 )
   {
      lon = -lon;
      char_x = 'W';
   }
   else if( lon >= 360.0 )
   {
      lon -= 360.0;
      char_x = 'E';
   }
   else if( lon >= 180.0 )
   {
      lon = 180.0 - ( lon - 180.0 );
      char_x = 'W';
   }
   else
     char_x = 'E';
   
   if( lat < 0.0 )
   {
      lat = -lat;
      char_y = 'S';
   }
   else
     char_y = 'N';
   
   x_deg = Math.trunc( lon );
   x_min = Math.trunc( ( lon - x_deg ) * 60.0 );
   x_sec = Math.trunc( ( lon - x_deg - x_min / 60.0 ) * 3600.0 );
   
   y_deg = Math.trunc( lat );
   y_min = Math.trunc( ( lat - y_deg ) * 60.0 );
   y_sec = Math.trunc( ( lat - y_deg - y_min / 60.0 ) * 3600.0 );
      
   return "Lon=" + x_deg + "\u00B0" +
     padded( x_min ) + "\'" + padded( x_sec ) + "\"" + char_x +
     "  Lat=" + y_deg + "\u00B0" + 
     padded( y_min ) + "\'" + padded( y_sec ) + "\"" + char_y;
}

//////////////////////////////////////////////////////////////////////////
// Pads the value with 0 if needed to have a constant field width. 
//////////////////////////////////////////////////////////////////////////
function padded( /* int */ value )   /* String */
{
   if( value < 10 )
     return "0" + value;
   else
     return "" + value;
}

//////////////////////////////////////////////////////////////////////////
// Zoom to the US area after a few seconds to show details.
//////////////////////////////////////////////////////////////////////////
function ZoomToUS()
{
   // Show zoom message.
   Drawing.SetDResource( "Map/USZoomingMessage/Visibility", 1.0 );
   Drawing.Update();

   /* GISExtent is in lon/lat for the rectangular GIS projection,
      and in meters for the orthographic projection.
      To find proper values, zoom the map in the GlgBuilder and 
      copy the GISExtent values. */
   
   // Zoom to the US boundaries on detailed map.
   GISObject[ 1 ].SetGResource( "GISCenter", -95.35, 37.37, 0.0 );
   GISObject[ 1 ].SetGResource( "GISExtent", 69.71, 34.85, 0.0 );
   
   if( MapProjection[ 0 ] == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
     // Rotate thumbnail globe too to show the same location.
     GISObject[ 0 ].SetGResource( "GISCenter", -95.35, 37.37, 0.0 );
   
   HandleZoomLevel();
   
   UpdateMap( 1 );
   UpdateMap( 0 );
   
   /* Reorder US zoom message to top, otherwise airplane icons 
      would be flying on top of it.
   */
   var us_message =   /* GlgObject */
     Drawing.GetResourceObject( "Map/USZoomingMessage" );
   Map[1].ReorderElement( Map[1].GetIndex( us_message ),
                          Map[1].GetSize() - 1 );

   Drawing.Update();

   // Erase zoom message after a delay.
   zoom_timer = setTimeout( ZoomToUSEnd, USZoomDelay2 );
}

//////////////////////////////////////////////////////////////////////////
// Remove the US zooming message after a few seconds.
//////////////////////////////////////////////////////////////////////////
function ZoomToUSEnd()
{
   Drawing.SetDResource( "Map/USZoomingMessage/Visibility", 0.0 );
   Drawing.Update();
}

//////////////////////////////////////////////////////////////////////////////
// Loads any assets required by the application and invokes the specified
// callback when done.
// Alternatively, the application's drawing can be loaded as an asset here
// as well, so that it starts loading without waiting for other assets to
// finish loading.
//////////////////////////////////////////////////////////////////////////////
function LoadAssets( callback )
{
   /* HTML5 doesn't provide a scrollbar input element (only a range input 
      html element is available). This application needs to load GLG scrollbars
      used for integrated chart scrolling. For each loaded scrollbar, the 
      AssetLoaded callback is invoked with the supplied data.
   */
   GLG.LoadWidgetFromURL( "scrollbar_h.g", null, AssetLoaded,
                          { name: "scrollbar_h", callback: callback } );
   GLG.LoadWidgetFromURL( "scrollbar_v.g", null, AssetLoaded,
                          { name: "scrollbar_v", callback: callback } );
}

//////////////////////////////////////////////////////////////////////////////
function AssetLoaded( glg_object, data, path )
{
   if( data.name == "scrollbar_h" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgHScrollbar", glg_object );
   }
   else if( data.name == "scrollbar_v" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgVScrollbar", glg_object );
   }
   else
     console.error( "Unexpected asset name" );

   /* Define an internal variable to keep the number of loaded assets. */
   if( AssetLoaded.num_loaded == undefined )
     AssetLoaded.num_loaded = 1;
   else
     ++AssetLoaded.num_loaded;

   // Invoke the callback after all assets have been loaded.
   if( AssetLoaded.num_loaded == 2 )
     data.callback();
}

//////////////////////////////////////////////////////////////////////////////
// Changes drawing size while maintaining width/height aspect ratio.
//////////////////////////////////////////////////////////////////////////////
function SetDrawingSize( next_size )
{
   const ASPECT_RATIO = 800 / 650;

   // Settings for desktop displays.
   const MIN_WIDTH = 600;
   const MAX_WIDTH = 1000;
   const SCROLLBAR_WIDTH = 15;
   
   if( SetDrawingSize.size_index == undefined )   // first time
   {
      SetDrawingSize.size_index = 0;

      SetDrawingSize.small_sizes       = [ 1, 1.5,  2.,   2.5 ];
      SetDrawingSize.medium_sizes      = [ 1, 0.75, 1.25, 1.5 ];
      SetDrawingSize.large_sizes       = [ 1, 0.6,  1.25, 1.5 ];
      SetDrawingSize.num_sizes = SetDrawingSize.small_sizes.length;
      SetDrawingSize.is_mobile = ( screen.width <= 760 );

      window.addEventListener( "resize", ()=>{ SetDrawingSize( false ) } );
   }
   else if( next_size )
   {
      ++SetDrawingSize.size_index;
      SetDrawingSize.size_index %= SetDrawingSize.num_sizes;
   }

   var drawing_area = document.getElementById( "glg_area" );
   if( SetDrawingSize.is_mobile )
   {
      /* Mobile devices use constant device-width, adjust only the height 
         of the drawing to keep the aspect ratio.
      */
      drawing_area.style.height =
        "" + Math.trunc( drawing_area.clientWidth / ASPECT_RATIO ) + "px";
   }
   else   /* Desktop */
   {
      var span = document.body.clientWidth; 
      if( !SetDrawingSize.is_mobile )
        span -= SCROLLBAR_WIDTH;

      var start_width;
      if( span < MIN_WIDTH )
        start_width = MIN_WIDTH;
      else if( span > MAX_WIDTH )
        start_width = MAX_WIDTH;
      else
        start_width = span;

      var size_array;
      if( span < 600 )
        size_array = SetDrawingSize.small_sizes;
      else if( span < 800 )
        size_array = SetDrawingSize.medium_sizes;
      else
        size_array = SetDrawingSize.large_sizes;

      var size_coeff = size_array[ SetDrawingSize.size_index ];
      var width = Math.trunc( Math.max( start_width * size_coeff, MIN_WIDTH ) );
   
      drawing_area.style.width = "" + width + "px";
      drawing_area.style.height = "" + Math.trunc( width / ASPECT_RATIO ) + "px";
   }
}

//////////////////////////////////////////////////////////////////////////////
// Increases canvas resolution for mobile devices with HiDPI displays.
// Returns chosen coordinate scale factor.
//////////////////////////////////////////////////////////////////////////////
function SetCanvasResolution()
{
   // Set canvas resolution only for mobile devices with devicePixelRatio != 1.
   if( window.devicePixelRatio == 1. || !SetDrawingSize.is_mobile )
     return 1.0;   // Use coord scale = 1.0 for desktop.
   
   /* The first parameter defines canvas coordinate scaling with values 
      between 1 and devicePixelRatio. Values greater than 1 increase 
      canvas resolution and result in sharper rendering. The value of 
      devicePixelRatio may be used for very crisp rendering with very thin lines.

      Canvas scale > 1 makes text smaller, and the second parameter defines
      the text scaling factor used to increase text size.

      The third parameter defines the scaling factor that is used to
      scale down text in native widgets (such as native buttons, toggles, etc.)
      to match the scale of the drawing.
   */
   var coord_scale = 2.0;
   GLG.SetCanvasScale( coord_scale, 1.5, 0.75 );
   
   // Mobile devices use fixed device-width: disable Change Drawing Size button.
   var change_size_button = document.getElementById( "change_size" );
   if( change_size_button != null )
     change_size_button.parentNode.removeChild( change_size_button );

   return coord_scale;      // Chosen coord scale for mobile devices.
}

function NodeData( name, lon, lat )
{
   this.name = name;      /* String */
   this.lat_lon = GLG.CreateGlgPoint( lon, lat, 0 );   /* GlgPoint */
   this.graphics = new Array( 2 );  /* GlgObject[2] */
}

function PlaneData()
{
   this.name;                       /* String */
   this.lat_lon = GLG.CreateGlgPoint( 0, 0, 0 ); /* GlgPoint */
   this.flight_number = 0;          /* int */
   this.tooltip = new Array( 2 );   /* String[2] */
   this.graphics = new Array( 2 );  /* GlgObject[2] */
   this.from_node = null;           /* NodeData */
   this.to_node = null;             /* NodeData */
   this.path_position = 0;          /* double */
   this.path_position_last = 0;     /* double */
   this.speed = 0;                  /* double */
   this.has_angle = new Array( 2 ); /* boolean[2] */
   this.angle = new Array( 2 );     /* double[2] */
}
