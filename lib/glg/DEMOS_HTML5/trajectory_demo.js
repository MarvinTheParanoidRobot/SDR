//////////////////////////////////////////////////////////////////////////////
// 3D Trajectory Demo: demonstrates the use of the GIS Object to display
// 3D trajectories with ground tracks and drop lines.
// The GLG Map Server is used to display a globe in the orthographic 
// projection.
//
// The demo is written in pure HTML5 and JavaScript. The source code of the
// demo uses the GLG Toolkit JavaScript Library supplied by the included
// Glg*.js and GlgToolkit*.js files. The GLG library loads a GLG drawing
// and renders it on a web page, providing an API to handle user interaction
// with graphical objects in the drawing.
//
// The drawings are created using the GLG Graphics Builder, an interactive
// editor that allows to create grahical objects and define their dynamic
// behavior without any programming. The airplane icons are dynamic
// GLG objects created with the Graphics Builder.
//
// The background map is generated by the GLG Map Server, which is integrated
// inside of a GLG drawing as a GLG GIS Object. The GIS Object takes a
// complete care of the map display, automatically generating Map Server
// requests to re-generate the image when the map is panned or zoomed.
//
// By default, demo uses an asyncronous map loading request: when the globe is
// rotated, the program will continue to operate with the current globe view
// and will switch to the new globe view when the new map is ready.
// Alternatively, the USE_REQUEST variable in the code below may be set to false
// to change the orbit to match the new globe view right away when the globe
// is rotated, but no map will be displayed while the new map is being loaded.
//
// Except for the changes to comply with the JavaScript syntax, this source
// is identical to the source code of the corresponding C/C++/C# and Java
// desktop versions of the demo.
//
// This demo uses the GLG Map Server to display a map.
// The Map Server has to be installed either on the local host or on a
// remote web server. After the Map Server has been installed, modify the
// source code to set the SuppliedMapServerURL variable to point to the
// Map Server location.
//////////////////////////////////////////////////////////////////////////////

// Get a handle to the GLG Toolkit library.
var GLG = new GlgToolkit();

// Debugging aid: uncomment the next line to throw an exception on a GLG error.
//GLG.ThrowExceptionOnError( true, true, true );

// Set initial size of the drawing.
SetDrawingSize( false );

// Increase canvas resoultion for mobile devices.
var CoordScale = SetCanvasResolution();

/* Load a drawing from the trajectory.g file. 
   The LoadCB callback will be invoked when the drawing has been loaded.
*/
var drawing_file = ( MobileVersion ? "trajectory2.g" : "trajectory.g" );

GLG.LoadWidgetFromURL( drawing_file, null, LoadCB, null );

//////////////////////////////////////////////////////////////////////////////
function LoadCB( drawing, data, path )
{
   if( drawing == null )
   {
      window.alert( "Can't load drawing, check console message for details." );
      return;
   }
                
   // Define the element in the HTML page to display the drawing in.
   drawing.SetParentElement( "glg_area" );
   
   // Disable viewport border to use the border of the glg_area.
   drawing.SetDResource( "LineWidth", 0 );

   StartTrajectoryDemo( drawing );
}

//////////////////////////////////////////////////////////////////////////////
// Control variables and constants
//////////////////////////////////////////////////////////////////////////////

/* This demo uses the GLG Map Server to display a map.
   The Map Server has to be installed either on the local host or on a
   remote web server. After the Map Server has been installed, set the 
   SuppliedMapServerURL variable to point to the Map Server location:
   for example:
     SuppliedMapServerURL = "http://localhost/cgi-bin/GlmScript";
   or
     SuppliedMapServerURL = "http://www.myserver.com/cgi-bin/GlmScript";
   The SuppliedMapServerURL value overrides the URL of the GIS object in the
   drawing.
*/
var SuppliedMapServerURL = null;    /* String */

/* Set to true to use asynchronous map requests to load the new map: when the
   globe is rotated, the program will continue to operate with the current 
   globe view and will switch to the new globe view when the new map is ready.         
   If set to false, the program will change the orbit to match the new globe 
   view right away when the globe is rotated, but no map will be displayed 
   while the new map is being loaded.

   To preserve the 3D viewing persperctive, the ZoomIn and ZoomOut functionality
   in this demo is implemented via GIS object scaling instead of the GIS Zooming.
   As the result, the ZoomIn and ZoomOut operations are not affected by the 
   USE_REQUEST setting.
*/
var USE_REQUEST = true;

const UPDATE_INTERVAL = 30;   // Update interval in msec

const NUM_ITERATIONS = 500;

// Display a drop line for every DROP_LINE_INTERVAL iterations.
const DROP_LINE_INTERVAL = 20;    

var CraftIcon = new Array( 2 );   /* GlgObject[2] */
var
   Drawing,                  /* GlgObject */
   Map,                      /* GlgObject : map viewport */
   GISObject,                /* GlgObject */
   GISArray,                 /* GlgObject */
   TrajectoryEdgeTemplate,   /* GlgObject */
   TrajectoryFillTemplate,   /* GlgObject */
   DropLineTemplate,         /* GlgObject */
   Craft = null,             /* GlgObject */
   TrajectoryEdge = null,    /* GlgObject */
   TrajectoryFill = null,    /* GlgObject */
   DropLineArray = null,     /* GlgObject */
   /* Provides visual feedback when the user defines the trajectory's start
      and end points with the mouse.
   */
   NewTrajectoryPolygon = null;   /* GlgObject */

var
   // Center of the GIS projection.
   GISCenter,                                       /* GlgPoint */
   // The last craft position, is used to calculate heading angles.
   PrevPosition = GLG.CreateGlgPoint( 0, 0, 0 ),    /* GlgPoint */ 
   Position = GLG.CreateGlgPoint( 0, 0, 0 ),        /* GlgPoint */ 
   GroundPosition = GLG.CreateGlgPoint( 0, 0, 0 ),  /* GlgPoint */ 
   CursorPosition = GLG.CreateGlgPoint( 0, 0, 0 );  /* GlgPoint */ 

var
   UpdateCount = 0,             /* int */
   ZoomLevel = 2;               /* int */

var
   Pause = false,               /* boolean */
   NewTrajectoryMode = false;   /* boolean */

// Simulation parameters.

// Maximum height of the trajectory, may be changed with a slider.
var TrajectoryHeight = 400000.0;    /* double */

// Trajectory curvature value, may be changed with a slider.
var Curvature = -1.75;    /* double */
var CurvatureY;           /* double */
 /* Used for simulation; in abstract units. */
var TrajectoryLength;     /* double */

/* Initial values for the start and end of the trajectory; may be changed
   interactively using the mouse. */
var   /* GlgPoint */
   StartPoint = GLG.CreateGlgPoint( -80.644861,       28.572872,       0.0 ),
   EndPoint   = GLG.CreateGlgPoint( -80.644861 + 5.0, 28.572872 - 3.0, 0.0 );

// Are used to define the trajectory's start and end points with the mouse.
var
Point1 = GLG.CreateGlgPoint( 0, 0, 0 ),        /* GlgPoint */
  Point2 = GLG.CreateGlgPoint( 0, 0, 0 );        /* GlgPoint */

// Temporary objects used for simulation math.
var
   CraftAngles = GLG.CreateGlgPoint( 0, 0, 0 ),       /* GlgPoint */
   CurrXYZ = GLG.CreateGlgPoint( 0, 0, 0 ),           /* GlgPoint */
   PrevXYZ = GLG.CreateGlgPoint( 0, 0, 0 ),           /* GlgPoint */
   TrajectoryVector = GLG.CreateGlgPoint( 0, 0, 0 ),  /* GlgPoint */
   // Normal to the trajectory's general direction.   /* GlgPoint */
   NormalVector = GLG.CreateGlgPoint( 0, 0, 0 );      /* GlgPoint */

var
   MapLoaded = false,   /* boolean */
   InitialLoad = true;  /* boolean */

var timer = null;

var gis_request_observer = null;
   
//////////////////////////////////////////////////////////////////////////////
function StartTrajectoryDemo( drawing )
{
   Drawing = drawing;

   InitDrawing();
   
   Drawing.SetupHierarchy();

   Drawing.Update();

   // Start periodic updates.
   timer = setTimeout( UpdatePosition, UPDATE_INTERVAL );
}

//////////////////////////////////////////////////////////////////////////////
// Initializes satellite icons and orbits.
//////////////////////////////////////////////////////////////////////////////
function InitDrawing()
{
   // Get ID of the map viewport.
   Map = Drawing.GetResourceObject( "Map" );

   // Get ID of the GIS object.
   GISObject = Map.GetResourceObject( "GISObject" );   

   /* Get ID of the GIS Object's GISArray, which holds all icons displayed
      on top of the map in lat/lon coordinates.
   */
   GISArray = GISObject.GetResourceObject( "GISArray" );

   /* Get trajectory templates and remove them from the drawing initially.
      Each template is a polygon with 2 points that stores graphical
      attributes of the trajectory, to allow the user to define 
      the attributes interactively via the Graphics Builder.
      One polygon is used for the edge of the trajectory, and another
      polygon is used for semi-transparent fill.
      Alternatively, template polygons can be created programmatically.
   */
   TrajectoryEdgeTemplate = Map.GetResourceObject( "TrajectoryEdgeTemplate" );
   Map.DeleteThisObject( TrajectoryEdgeTemplate );
      
   TrajectoryFillTemplate = Map.GetResourceObject( "TrajectoryFillTemplate" );
   Map.DeleteThisObject( TrajectoryFillTemplate );

   /* Vertical drop lines. */
   DropLineTemplate = Map.GetResourceObject( "DropLineTemplate" );
   Map.DeleteThisObject( DropLineTemplate );

   /* Delete craft icons from the top drawing, where it was placed for 
      the ease of editing. The selected icon will be added inside the 
      GISArray to position it in lat/lon. 
   */
   for( var i=0; i<2; ++i )
   {
      CraftIcon[i] = Map.GetResourceObject( i != 0 ? "Craft1" : "Craft0" );
      Map.DeleteThisObject( CraftIcon[ i ] );
   }
   
   /* Query the center of the GIS projection. */
   GISCenter = GISObject.GetGResource( "GISCenter" );

   // Set initial trajectory height and curvature to predefined values.
   Drawing.SetDResource( "Toolbar/HeightSlider/ValueX", TrajectoryHeight );
   Drawing.SetDResource( "Toolbar/CurvatureSlider/ValueX", Curvature );
   
   /* Set the GIS Zoom mode. It was set and saved with the drawing, 
      but do it again programmatically just in case.
   */
   Drawing.SetZoomMode( null, GISObject, null, GLG.GlgZoomMode.GIS_ZOOM_MODE );
   
   SetZoomLevel();

   /* Add Input and Trace callbacks used to handle user interaction. */
   Drawing.AddListener( GLG.GlgCallbackType.INPUT_CB, InputCallback );
   Drawing.AddListener( GLG.GlgCallbackType.TRACE_CB, TraceCallback );
   
   if( USE_REQUEST )
     gis_request_observer =
       GLG.CreateGlgGISRequestObserver( RequestUpdate, RequestAdjustment,
                                        AdjustRequest );
   SetMapLoading( true );
}

//////////////////////////////////////////////////////////////////////////
// Handle user interaction.
//////////////////////////////////////////////////////////////////////////
function InputCallback( /* GlgObject */ vp, /* GlgObject */ message_obj )
{
   var
     origin,
     format,
     action,
     subaction;
   
   origin = message_obj.GetSResource( "Origin" );
   format = message_obj.GetSResource( "Format" );
   action = message_obj.GetSResource( "Action" );
   subaction = message_obj.GetSResource( "SubAction" );

   if( format == "Button" )         // Handle button clicks
   {
      if( action != "Activate" && action != "ValueChanged" )
        return;

      AbortNewTrajectoryMode();	 

      if( origin == "Restart" )
      {
         Restart();
      }
      else if( origin == "PauseResume" )
      {
         Pause = ( message_obj.GetDResource( "OnState" ) == 0 );
      }
      else if( origin == "IconType" )
      {
         CreateCraftIcon();   /* Change icon. */
         
         // Set craft position and angles, same as in UpdatePosition().
         if( Pause && UpdateCount != 0 ) 
         {
            GetCraftPosition( Position ); 
            Craft.SetGResourceFromPoint( "Position", Position ); 
            SetCraftAngles( Position, PrevPosition ); 
            Craft.SetDResource( "Visibility", 1.0 ); 
            Drawing.Update();
         }
      }
      else if( origin == "NewTrajectory" )
      {
         NewTrajectoryMode = true;
         Map.SetDResource( "Prompt/Visibility", 1.0 );
         Map.Update();
      }
      else if( origin == "Up" )
        Pan( 'u' );
      else if( origin == "Down" )
        Pan( 'd' );
      else if( origin == "Left" )
        Pan( 'l' );
      else if( origin == "Right" )
        Pan( 'r' );
      else if( origin == "ZoomIn" )
      {
         if( ZoomLevel < 4 )
         {
            ++ZoomLevel;
            SetZoomLevel();
         }
      }
      else if( origin == "ZoomOut" )
      {
         if( ZoomLevel > 0 )
         {
            --ZoomLevel;
            SetZoomLevel();
         }
      }
   }
   else if( format == "Slider" )
   {
      if( action == "ValueChanged" )
        AbortNewTrajectoryMode();
   }
}

//////////////////////////////////////////////////////////////////////////
// Restart simulation with new parameters.
//////////////////////////////////////////////////////////////////////////
function Restart()
{
   UpdateCount = 0;   // Reset update counter
   
   // Resume if was paused.
   Pause = false;
   Drawing.SetDResource( "Toolbar/PauseResume/OnState", 1.0 );
   Drawing.Update();
}
   
//////////////////////////////////////////////////////////////////////////
// Pan the map in the specified direction.
//////////////////////////////////////////////////////////////////////////
function Pan( /* String */ direction )
{
   var distance;    /* double */

   /* Pan in lat/lon instead of screen pixels to allow contineous rotation
      of the globe upside down.
   */
   switch( direction )
   {
    default:
    case 'u': direction = 'Y'; distance =  8.0; break;
    case 'd': direction = 'Y'; distance = -8.0; break;
    case 'l': direction = 'X'; distance = -8.0; break;
    case 'r': direction = 'X'; distance =  8.0; break;
   }

   SetMapLoading( true );

   if( USE_REQUEST )
   {
      Map.RequestGISZoom( null, direction, distance, gis_request_observer );

      /* The new center of the GIS projection will be queried when the new map
         is installed. */
   }
   else
   {
      Map.SetZoom( null, direction, distance );
      Map.Update();
      
      /* Query the new center of the GIS projection. */
      GISCenter = GISObject.GetGResource( "GISCenter" );
   }
}

//////////////////////////////////////////////////////////////////////////
function SetZoomLevel()
{
   var scale;   /* double */
      
   switch( ZoomLevel )
   {
    case 0: scale = 3.0; break;
    case 1: scale = 5.0; break;
    default:
    case 2: scale = 8.25; break;
    case 3: scale = 10.0; break;
    case 4: scale = 12.0; break;
   }

   SetMapLoading( true );
   InitialLoad = true;
   
   /* Instead of the GIS zoom, GIS object is scaled (via the attached scale 
      transformation) to have the GIS object partially clipped out with 
      the top of it visible as a horizon line.      
      Scaling the GIS object does not change projection center.
   */
   GISObject.SetDResource( "GISScale", scale );
      
   // Set scaling limits depending on the resolution of available data.
   Map.SetDResource( "ZoomIn/DisableInput", ZoomLevel >= 4 ? 10.0 : 0.0 );
   Map.SetDResource( "ZoomOut/DisableInput", ZoomLevel <= 0 ? 1.0 : 0.0 );

   Map.Update();
}

//////////////////////////////////////////////////////////////////////////
// Updates moving object with new position data.
//////////////////////////////////////////////////////////////////////////
function UpdatePosition()
{   
   var
     trajectory,   /* GlgObject */
     drop_line;    /* GlgObject */
   var i;          /* int */

   /* If UseRequest=true, the map loading message will be erased when the 
      request is installed.
   */
   if( ( InitialLoad || !USE_REQUEST && !MapLoaded ) &&
       Math.trunc( GISObject.GetDResource( "ImageLoaded" ) ) != 0 )
   {
      SetMapLoading( false );
      InitialLoad = false;
   }

   if( !Pause )
   {
      if( UpdateCount == NUM_ITERATIONS )
        UpdateCount = 0; // Reached the end of the trajectory: start over.
         
      // Obtain new craft position. 
      GetCraftPosition( Position );

      if( UpdateCount == 0 )     // First time.
      {
         InitSimulationParameters();
         CreateCraftIcon();
      }
      else
      {
         /* Update craft position in the drawing with new data.
            Also update angles: previous position is valid.
         */
         Craft.SetGResourceFromPoint( "Position", Position );      
         SetCraftAngles( Position, PrevPosition );
         
         Craft.SetDResource( "Visibility", 1.0 );  // Make it visible.
      }

      // Store previous position to calculate heading angles.
      PrevPosition.CopyFrom( Position );

      // Update craft trajectory.
      if( UpdateCount == 0 )
      {
         // First time: add trajectory polygons to the GIS Object. 
         if( TrajectoryEdge != null )
         {
            // Destroy previous trajectory polygons.
            GISArray.DeleteThisObject( TrajectoryEdge );
            TrajectoryEdge = null;
            
            GISArray.DeleteThisObject( TrajectoryFill );
            TrajectoryFill = null;
            
            if( DropLineArray != null )
            {
               GISArray.DeleteThisObject( DropLineArray );
               DropLineArray = null;
            }
         }
         
         for( i=0; i<2; ++i )
         {
            if( i == 0 )
            {
               TrajectoryEdge = TrajectoryEdgeTemplate.CopyObject();
               trajectory = TrajectoryEdge;
            }
            else
            {
               TrajectoryFill = TrajectoryFillTemplate.CopyObject();
               trajectory = TrajectoryFill;
            }
            
            // Use two points initially, set both points to the same lat/lon.
            SetPolygonPoint( trajectory, 0, Position );
            SetPolygonPoint( trajectory, 1, Position );
            
            /* Add to top to draw the trajectory first, with the craft 
               on top of it. */
            GISArray.AddObjectToTop( trajectory );
         }
      }
      else
      {
         GroundPosition.CopyFrom( Position );
         GroundPosition.z = 0.0;   // Zero elevation
         
         for( i=0; i<2; ++i )
         {
            trajectory = ( i==0 ? TrajectoryEdge : TrajectoryFill );
               
            /* Add two points for every postion: one using the trajectory 
               elevation, and one at the ground level to show the ground 
               position.
            */
            AddPolygonPoint( trajectory, Position, true );
            AddPolygonPoint( trajectory, GroundPosition, false );
         }
         
         // Display a drop line for every DROP_LINE_INTERVAL iterations.
         if( ( UpdateCount % DROP_LINE_INTERVAL ) == 0 )
         {
            if( DropLineArray == null )
            {
               var position;   /* int */
               
               // First drop line: create a group to hold droplines.
               DropLineArray =
                 GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                                   GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
               
               // Add after trajectory polygons but before the craft.
               position = GISArray.GetIndex( Craft );
               GISArray.AddObjectAt( DropLineArray, position );
            }
            
            drop_line = DropLineTemplate.CopyObject();
            
            /* Draw a line from craft to the ground point (elev=0) with the
               same lat/lon.
            */
            SetPolygonPoint( drop_line, 0, Position );
            SetPolygonPoint( drop_line, 1, GroundPosition );
            
            DropLineArray.AddObjectToTop( drop_line );
         }
      }
      
      ++UpdateCount;
      Drawing.Update();
   }
   
   // Restart update timer
   timer = setTimeout( UpdatePosition, UPDATE_INTERVAL );
}

//////////////////////////////////////////////////////////////////////////
function SetMapLoading( /* boolean */ show )
{
   if( show )
   {
      Drawing.SetDResource( "Map/LoadingMessage/Visibility", 1 );
      MapLoaded = false;
   }
   else
   {
      Drawing.SetDResource( "Map/LoadingMessage/Visibility", 0 );
      MapLoaded = true;
   }
}

//////////////////////////////////////////////////////////////////////////
// Creates a craft icon based on the icon type requested by the IconType 
// toolbar button.
//////////////////////////////////////////////////////////////////////////
function CreateCraftIcon()
{
   var icon_type;   /* int */
      
   // Delete previously used craft icon.
   if( Craft != null )
   {
      GISArray.DeleteThisObject( Craft );
      Craft = null;
   }
   
   // Query icon type requested by the IconType toolbar button.
   icon_type =
     ( Drawing.GetDResource( "Toolbar/IconType/OnState" ) == 0 ? 0 : 1 );

   // Add a craft icon.
   Craft = CraftIcon[ icon_type ];
   
   if( MobileVersion )
     // Increase icon size for the mobile version.
     Craft.SetDResource( "Scale", 2. );

   // Make invisible initially: has no position or angle information.
   Craft.SetDResource( "Visibility", 0.0 );
   
   // Add to the drawing inside the GIS object to position in lat/lon.
   GISArray.AddObjectToBottom( CraftIcon[ icon_type ] );
}

//////////////////////////////////////////////////////////////////////////
// Is used to obtain coordinates of the mouse click when defining 
// the trajectory's start and end points with the mouse.
//////////////////////////////////////////////////////////////////////////
function TraceCallback( /* GlgObject */ viewport, /* GlgTraceData */ trace_info )
{
   var event_type = trace_info.event_type;

   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
    case GLG.GlgEventType.MOUSE_PRESSED:
      if( trace_info.button != 1 )
      {
         AbortNewTrajectoryMode();	 
         return;  // Use only the left button clicks.
      }
      break;
   }
   
   /* Use the Map area events only. */
   if( !trace_info.viewport.Equals( Map ) )
     return;
      
   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
    case GLG.GlgEventType.MOUSE_PRESSED:
      if( !NewTrajectoryMode )
        return;

      if( event_type == GLG.GlgEventType.TOUCH_START )
        GLG.SetTouchMode();        /* Start dragging via touch events. */

      // Delete the previous trajectory polygon, if any.
      if( NewTrajectoryPolygon != null )
      {
         AbortNewTrajectoryMode();
         NewTrajectoryMode = true;    // Restore mode.
      }
      
      // Define the start point of the trajectory.
      CursorPosition.x = trace_info.mouse_x * CoordScale;
      CursorPosition.y = trace_info.mouse_y * CoordScale;
      CursorPosition.z = 0.0;
      
      /* COORD_MAPPING_ADJ is added to the cursor coordinates for precise 
         pixel mapping.
      */
      CursorPosition.x += GLG.COORD_MAPPING_ADJ;
      CursorPosition.y += GLG.COORD_MAPPING_ADJ;
      
      /* Convert screen coordinates of the mouse to the world coordinates 
         inside the GIS Object's GISArray - lat/lon. */ 
      GISArray.ScreenToWorld( true, CursorPosition, Position );
                     
      NewTrajectoryPolygon =
        GLG.CreateObject( GLG.GlgObjectType.POLYGON, 2, null, null, null );
      NewTrajectoryPolygon.SetGResource( "EdgeColor", 1.0, 1.0, 0.0 );
      
      // Initially, set both polygon points to the the mouse position.
      Point1.CopyFrom( Position );
      Point2.CopyFrom( Position );
      SetPolygonPoint( NewTrajectoryPolygon, 0, Point1 );
      SetPolygonPoint( NewTrajectoryPolygon, 1, Point1 );

      GISObject.AddObjectToBottom( NewTrajectoryPolygon );
      Map.Update();
      break;
      
    case GLG.GlgEventType.TOUCH_MOVED:
    case GLG.GlgEventType.MOUSE_MOVED:
      if( !NewTrajectoryMode || NewTrajectoryPolygon == null )
        return;

      // Start point has been defined: show the end point when dragging.
      CursorPosition.x = trace_info.mouse_x * CoordScale;
      CursorPosition.y = trace_info.mouse_y * CoordScale;
      CursorPosition.z = 0.0;
         
      /* COORD_MAPPING_ADJ is added to the cursor coordinates for 
         precise pixel mapping.
      */
      CursorPosition.x += GLG.COORD_MAPPING_ADJ;
      CursorPosition.y += GLG.COORD_MAPPING_ADJ;

      /* Convert screen coordinates of the mouse to the world coordinates 
         inside the GIS Object's GISArray - lat/lon.
      */ 
      GISArray.ScreenToWorld( true, CursorPosition, Position );
      Position.z = 0.0;   // Use elevation = 0
         
      // Store the end point of the trajectory.
      Point2.CopyFrom( Position );

      SetPolygonPoint( NewTrajectoryPolygon, 1, Position );
      Map.Update();
      break;

    case GLG.GlgEventType.TOUCH_END:
    case GLG.GlgEventType.MOUSE_RELEASED:
      if( trace_info.button != 1 ||
          !NewTrajectoryMode || NewTrajectoryPolygon == null )
        return;

      AbortNewTrajectoryMode();   // Delete NewTrajectoryPolygon.

      if( Point1.x == Point2.x && Point1.y == Point2.y )
        return;    // Mouse didn't move: no trajectory was defined.

      /* Trajectory was defined: store the new start and end point. */      
      StartPoint.CopyFrom( Point1 );
      EndPoint.CopyFrom( Point2 );

      // Set a smaller curvature to follow the start/end line.
      Curvature = -0.2;
      Drawing.SetDResource( "Toolbar/CurvatureSlider/ValueX", Curvature ); 
      
      Restart();             // Restart with the new trajectory.
      Drawing.Update();
      break;
      
    default: return;
   }
}

//////////////////////////////////////////////////////////////////////////
// Deletes NewTrajectoryPolygon if created.
//////////////////////////////////////////////////////////////////////////
function AbortNewTrajectoryMode()
{
   // Remove prompt if it's visible.
   Map.SetDResourceIf( "Prompt/Visibility", 0., true );

   if( NewTrajectoryPolygon != null )
   {
      if( GISObject.ContainsObject( NewTrajectoryPolygon ) )
        GISObject.DeleteThisObject( NewTrajectoryPolygon );
      
      NewTrajectoryPolygon = null;
      Map.Update();
   }
   NewTrajectoryMode = false;
}

//////////////////////////////////////////////////////////////////////////
// SIMULATION: returns craft postion (lon, lat and elevation above the
// Earth in meters) via the passed position parameter.
//////////////////////////////////////////////////////////////////////////
function GetCraftPosition( /* GlgPoint */ position )
{
   var rel_value, rel_sin;   /* double */
      
   rel_value = ( UpdateCount % NUM_ITERATIONS ) / NUM_ITERATIONS;
   rel_sin = Math.sin( Math.PI * rel_value );

   // Lon
   position.x = StartPoint.x + ( EndPoint.x - StartPoint.x ) * rel_value +
     NormalVector.x * TrajectoryLength * Curvature * rel_sin;

   // Lat
   position.y = StartPoint.y + ( EndPoint.y - StartPoint.y ) * rel_value +
     NormalVector.y * TrajectoryLength * CurvatureY * rel_sin;

   // Elevation
   position.z = TrajectoryHeight * rel_sin;
}

//////////////////////////////////////////////////////////////////////////
// SIMULATION: Set craft angles depending on its position on the globe
// and asimuthal angle. Angles are not needed if a simpler marker icon
// is used to mark position of the craft.
//////////////////////////////////////////////////////////////////////////
function SetCraftAngles( /* GlgPoint */ curr_position,
                         /* GlgPoint */ prev_position )
{
   GetGlobeAngles( curr_position, prev_position, CraftAngles );
   
   var yaw = CraftAngles.x;     /* double */
   var pitch = CraftAngles.y;   /* double */
   var roll = CraftAngles.z;    /* double */
   
   Craft.SetDResource( "Roll", roll );
   Craft.SetDResource( "Pitch", pitch );
   Craft.SetDResource( "Yaw", yaw );
}

//////////////////////////////////////////////////////////////////////////
// SIMULATION: calculates craft's heading angles based on the current
// and previous position. The angles are returned via the passed angles
// parameter.
//////////////////////////////////////////////////////////////////////////
function GetGlobeAngles( /* GlgPoint */ curr_position,
                         /* GlgPoint */ prev_position, /* GlgPoint */ angles )
{
   var            /* double */
     dx, dy, dz,
     rel_value,
     yaw, pitch, roll;
      
   /* Calculate angles using XYZ position on the globe. If Z coordinate
      is not required, GlgGISConvert() may be used to get X and Y screen 
      coordinates in pixels instead of GetPointXYZ().
   */
   
   /* XYZ of the first point, in meters */
   GetPointXYZ( curr_position, CurrXYZ );
   
   /* XYZ of the second point, in meters */
   GetPointXYZ( prev_position, PrevXYZ );
   
   dx = CurrXYZ.x - PrevXYZ.x;
   dy = CurrXYZ.y - PrevXYZ.y;
   dz = CurrXYZ.z - PrevXYZ.z;
   
   /* Visible heading angles on the globe in the current projection. */
   if( dx == 0.0 )
     yaw = ( dy != 0.0 ? ( dy > 0.0 ? 90.0 : -90.0 ) : 0.0 );
   else
   {
      yaw = Math.atan( dy / dx );
      yaw = RadToDeg( yaw );
      if( dx < 0.0 )
        yaw += 180.0;
   }
   
   if( dx == 0.0 && dy == 0.0 )
     pitch = - ( dz != 0.0 ? ( dz > 0.0 ? 90.0 : -90.0 ): 0.0 );
   else
   {
      pitch = - Math.atan( dz / Math.sqrt( dx * dx + dy * dy ) / 3.0 );
      pitch = RadToDeg( pitch );
   }
   
   rel_value = ( UpdateCount % NUM_ITERATIONS ) / NUM_ITERATIONS;
   
   // Roll it a bit. In an application, supply a real roll angle.
   roll = -60.0 * Math.sin( DegToRad( yaw ) ) * Math.sin( Math.PI * rel_value );

   angles.x = yaw;
   angles.y = pitch;
   angles.z = roll;
}

//////////////////////////////////////////////////////////////////////////
// SIMULATION: Initializes simulation parameters.
//////////////////////////////////////////////////////////////////////////
function InitSimulationParameters()
{
   var max_lat;   /* double */
      
   // Query requested trajectory height from the slider.
   TrajectoryHeight = Drawing.GetDResource( "Toolbar/HeightSlider/ValueX" );

   // Query requested trajectory curvature from the slider.
   Curvature = Drawing.GetDResource( "Toolbar/CurvatureSlider/ValueX" );

   TrajectoryVector.x = EndPoint.x - StartPoint.x;
   TrajectoryVector.y = EndPoint.y - StartPoint.y;
   
   // Obtain a normal vector used to curve the simulated trajectory.
   GetNormalVector( TrajectoryVector, NormalVector );
   
   /* Calculate trajectory length in abstract units for simulation. */
   TrajectoryLength = Math.sqrt( TrajectoryVector.x * TrajectoryVector.x +
                                 TrajectoryVector.y * TrajectoryVector.y );

   /* Point with the maximum lat. */
   max_lat = StartPoint.y + ( EndPoint.y - StartPoint.y ) * 
     NormalVector.y * TrajectoryLength * Curvature;
   if( max_lat > 89.0 )
     max_lat = 89.0;
   else if( max_lat < -89.0 )
     max_lat = -89.0;
   else 
     max_lat = 0.0;
   
   // Limit Y curvature to avoid flying "off the globe".
   if( max_lat != 0.0 )
     CurvatureY = ( max_lat - StartPoint.y ) / 
       ( NormalVector.y * TrajectoryLength * ( EndPoint.y - StartPoint.y ) );
   else
     CurvatureY = Curvature;
}

//////////////////////////////////////////////////////////////////////////
// SIMULATION: Returns 2D normal vector of length=1.
//////////////////////////////////////////////////////////////////////////
function GetNormalVector( /* GlgPoint */ vector, /* GlgPoint */ normal )
{
   var length;   /* double */
      
   if( vector.x == 0.0 )
   {
      if( vector.y == 0.0 )        
        normal.x = 0.0;    // NULL vector: return NULL as a normal.
      else
        normal.x = 1.0;
      
      normal.y = 0.0;
   }
   else if( vector.y == 0.0 )
   {
      normal.x = 0.0;
      normal.y = 1.0;
      }
   else
   {
      normal.x = vector.y;
      normal.y = - vector.x;
      length = Math.sqrt( normal.x * normal.x + normal.y * normal.y );
      if( length != 1.0 )
      {
            normal.x /= length;
            normal.y /= length;
      }
   }
}

//////////////////////////////////////////////////////////////////////////
// Returns XYZ coordinate of the lat/lon point, in meters.
//////////////////////////////////////////////////////////////////////////
function GetPointXYZ( /* GlgPoint */ lat_lon, /* GlgPoint */ xyz )
{
   var               /* double */
     globe_radius,
     phi, phi1, lon_diff,
     cos_phi, sin_phi,
     cos_phi1, sin_phi1,
     cos_lon_diff, sin_lon_diff;
   
   phi = DegToRad( lat_lon.y );
   phi1 = DegToRad( GISCenter.y );
   lon_diff = DegToRad( lat_lon.x - GISCenter.x );
   
   // Use the average value plus elevation.
   globe_radius = ( GLG.EQUATOR_RADIUS + GLG.POLAR_RADIUS ) / 2.0;
   globe_radius += lat_lon.z;
      
   cos_phi = Math.cos( phi );
   sin_phi = Math.sin( phi );
   cos_phi1 = Math.cos( phi1 );
   sin_phi1 = Math.sin( phi1 );
   cos_lon_diff = Math.cos( lon_diff );
   sin_lon_diff = Math.sin( lon_diff );
   
   xyz.x = globe_radius * cos_phi * sin_lon_diff;
   xyz.y = globe_radius *
     ( cos_phi1 * sin_phi - sin_phi1 * cos_phi * cos_lon_diff );
   xyz.z = globe_radius *
     ( cos_lon_diff * cos_phi1 * cos_phi + sin_phi1 * sin_phi );
}

//////////////////////////////////////////////////////////////////////////
function SetPolygonPoint( /* GlgObject */ polygon, /* int */ point_index,
                          /* GlgPoint */ position )
{
   var point;   /* GlgObject */

   point = polygon.GetElement( point_index );
   point.SetGResourceFromPoint( null, position );
}

//////////////////////////////////////////////////////////////////////////
function AddPolygonPoint( /* GlgObject */ polygon, /* GlgPoint */ position,
                          /* boolean */ add_at_the_end )
{
   var point;   /* GlgObject */

   // Copy the first point and add it at the end of the polygon.
   point = polygon.GetElement( 0 );
   point = point.CopyObject();

   point.SetGResourceFromPoint( null, position );
   if( add_at_the_end )
     polygon.AddObjectToBottom( point );
   else                // Add at the beginning of the polygon.
     polygon.AddObjectToTop( point );
}

//////////////////////////////////////////////////////////////////////////
function DegToRad( /* double */ angle )   /* double */
{
   return angle / 180.0 * Math.PI;
}

//////////////////////////////////////////////////////////////////////////
function RadToDeg( /* double */ angle )   /* double */
{
   return angle / Math.PI * 180.0;
}

//////////////////////////////////////////////////////////////////////////////
// Changes drawing size while maintaining width/height aspect ratio.
//////////////////////////////////////////////////////////////////////////////
function SetDrawingSize( next_size )
{
   const ASPECT_RATIO = 450 / 525;

   // Settings for desktop displays.
   const MIN_WIDTH = 500;
   const MAX_WIDTH = 1000;
   const SCROLLBAR_WIDTH = 15;
   
   if( SetDrawingSize.size_index == undefined )   // first time
   {
      SetDrawingSize.size_index = 0;

      SetDrawingSize.small_sizes       = [ 1, 1.5,  2.,   2.5 ];
      SetDrawingSize.medium_sizes      = [ 1, 0.75, 1.25, 1.5 ];
      SetDrawingSize.large_sizes       = [ 1, 0.6,  1.25, 1.5 ];
      SetDrawingSize.num_sizes = SetDrawingSize.small_sizes.length;
      SetDrawingSize.is_mobile = ( screen.width <= 760 );

      window.addEventListener( "resize", ()=>{ SetDrawingSize( false ) } );
   }
   else if( next_size )
   {
      ++SetDrawingSize.size_index;
      SetDrawingSize.size_index %= SetDrawingSize.num_sizes;
   }

   var drawing_area = document.getElementById( "glg_area" );
   if( SetDrawingSize.is_mobile )
   {
      /* Mobile devices use constant device-width, adjust only the height 
         of the drawing to keep the aspect ratio.
      */
      drawing_area.style.height =
        "" + Math.trunc( drawing_area.clientWidth / ASPECT_RATIO ) + "px";
   }
   else   /* Desktop */
   {
      var span = document.body.clientWidth; 
      if( !SetDrawingSize.is_mobile )
        span -= SCROLLBAR_WIDTH;

      var start_width;
      if( span < MIN_WIDTH )
        start_width = MIN_WIDTH;
      else if( span > MAX_WIDTH )
        start_width = MAX_WIDTH;
      else
        start_width = span;

      var size_array;
      if( span < 600 )
        size_array = SetDrawingSize.small_sizes;
      else if( span < 800 )
        size_array = SetDrawingSize.medium_sizes;
      else
        size_array = SetDrawingSize.large_sizes;

      var size_coeff = size_array[ SetDrawingSize.size_index ];
      var width = Math.trunc( Math.max( start_width * size_coeff, MIN_WIDTH ) );
   
      drawing_area.style.width = "" + width + "px";
      drawing_area.style.height = "" + Math.trunc( width / ASPECT_RATIO ) + "px";
   }
}

//////////////////////////////////////////////////////////////////////////////
// Increases canvas resolution for mobile devices with HiDPI displays.
// Returns chosen coordinate scale factor.
//////////////////////////////////////////////////////////////////////////////
function SetCanvasResolution()
{
   // Set canvas resolution only for the mobile version of the demo.
   if( !MobileVersion )
     return 1.0;   // Use coord scale = 1.0 for desktop.

   /* The first parameter defines canvas coordinate scaling with values 
      between 1 and devicePixelRatio. Values greater than 1 increase 
      canvas resolution and result in sharper rendering. The value of 
      devicePixelRatio may be used for very crisp rendering with very thin lines.

      Canvas scale > 1 makes text smaller, and the second parameter defines
      the text scaling factor used to increase text size.

      The third parameter defines the scaling factor that is used to
      scale down text in native widgets (such as native buttons, toggles, etc.)
      to match the scale of the drawing.
   */
   var coord_scale = 2.0;
   GLG.SetCanvasScale( coord_scale, 1.75, 0.6 );
   
   // Mobile devices use fixed device-width: disable Change Drawing Size button.
   var change_size_button = document.getElementById( "change_size" );
   if( change_size_button != null )
     change_size_button.parentNode.removeChild( change_size_button );

   return coord_scale;      // Chosen coord scale for mobile devices.
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface, requests no adjustement callbacks.
//////////////////////////////////////////////////////////////////////////
function RequestAdjustment()
{
   return false;
}
//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: adjustement callback.
//////////////////////////////////////////////////////////////////////////
function AdjustRequest( /* GlgGISRequestData */ request_data )
{
   return false;
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: receives status update notifications.
//////////////////////////////////////////////////////////////////////////
function RequestUpdate( /* GlgObject */ gis_object, status )
{
   switch( status )
   {
    case GLG.GlgGISRequestStatus.GIS_REQUEST_READY:
      if( GISObject.InstallGISRequest( null ) )
      {
         Map.Update();

         /* Query the new center of the GIS projection. */
         GISCenter = GISObject.GetGResource( "GISCenter" );
      }
      else
        console.log( "Failed to install map request." );
      break;
      
    default:
      console.log( "Aborting previous GIS request." ); 
      break;
   }

   SetMapLoading( false );
}
