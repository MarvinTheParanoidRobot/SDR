//////////////////////////////////////////////////////////////////////////////
// Satellite Orbits Demo: demonstrates the use of the GIS Object to position 
// satellites by specifying lat/lon coordinates and elevation above the Earth.
// The GLG Map Server is used to display a globe in the orthographic 
// projection.
//
// The demo is written in pure HTML5 and JavaScript. The source code of the
// demo uses the GLG Toolkit JavaScript Library supplied by the included
// Glg*.js and GlgToolkit*.js files. The GLG library loads a GLG drawing
// and renders it on a web page, providing an API to handle user interaction
// with graphical objects in the drawing.
//
// The drawings are created using the GLG Graphics Builder, an interactive
// editor that allows to create grahical objects and define their dynamic
// behavior without any programming. The airplane icons are dynamic
// GLG objects created with the Graphics Builder.
//
// The background map is generated by the GLG Map Server, which is integrated
// inside of a GLG drawing as a GLG GIS Object. The GIS Object takes a
// complete care of the map display, automatically generating Map Server
// requests to re-generate the image when the map is panned or zoomed.
//
// By default, demo uses an asyncronous map loading request: when the globe is
// rotated, the program will continue to operate with the current globe view
// and will switch to the new globe view when the new map is ready.
// Alternatively, the USE_REQUEST variable in the code below may be set to false
// to change satellite orbits to match the new globe view right away when the
// globe is rotated, but no map will be displayed while the new map is being
// loaded.
//
// Except for the changes to comply with the JavaScript syntax, this source
// is identical to the source code of the corresponding C/C++/C# and Java
// desktop versions of the demo.
//
// This demo uses the GLG Map Server to display a map.
// The Map Server has to be installed either on the local host or on a
// remote web server. After the Map Server has been installed, modify the
// source code to set the SuppliedMapServerURL variable to point to the
// Map Server location.
//////////////////////////////////////////////////////////////////////////////

// Get a handle to the GLG Toolkit library.
var GLG = new GlgToolkit();

// Debugging aid: uncomment the next line to throw an exception on a GLG error.
//GLG.ThrowExceptionOnError( true, true, true );

// Set initial size of the drawing.
SetDrawingSize( false );

// Increase canvas resoultion for mobile devices.
var CoordScale = SetCanvasResolution();

/* Load a drawing from the satellite.g file. 
   The LoadCB callback will be invoked when the drawing has been loaded.
*/
GLG.LoadWidgetFromURL( "satellite.g", null, LoadCB, null );

//////////////////////////////////////////////////////////////////////////////
function LoadCB( drawing, data, path )
{
   if( drawing == null )
   {
      window.alert( "Can't load drawing, check console message for details." );
      return;
   }
                
   // Define the element in the HTML page to display the drawing in.
   drawing.SetParentElement( "glg_area" );
   
   // Disable viewport border to use the border of the glg_area.
   drawing.SetDResource( "LineWidth", 0 );

   StartSatelliteDemo( drawing );
}

//////////////////////////////////////////////////////////////////////////////
// Control variables and constants
//////////////////////////////////////////////////////////////////////////////

/* This demo uses the GLG Map Server to display a map.
   The Map Server has to be installed either on the local host or on a
   remote web server. After the Map Server has been installed, set the 
   SuppliedMapServerURL variable to point to the Map Server location:
   for example:
     SuppliedMapServerURL = "http://localhost/cgi-bin/GlmScript";
   or
     SuppliedMapServerURL = "http://www.myserver.com/cgi-bin/GlmScript";
   The SuppliedMapServerURL value overrides the URL of the GIS object in the
   drawing.
*/
var SuppliedMapServerURL = null;    /* String */

/* Set to true to use asynchronous map requests to load the new map: when the
   globe is rotated, the program will continue to operate with the current 
   globe view and will switch to the new globe view when the new map is ready.         
   If set to false, the program will change the satellite orbits to match the
   new globe view right away when the globe is rotated, but no map will be 
   displayed while the new map is being loaded.
*/
var USE_REQUEST = true;

const UPDATE_INTERVAL = 30;   // Update interval in msec
const ANGLE_DELTA = 10.0;     // Defines pan distance.

// Simulation parameters. 
const SAT1_PERIOD = 500;
const SAT2_PERIOD = 400;

var
   Drawing,                 /* GlgObject */
   GISObject,               /* GlgObject */
   GISArray,                /* GlgObject */
   Satellite1,              /* GlgObject */
   Satellite2,              /* GlgObject */
   Satellite1_GroundTrack,  /* GlgObject */
   Satellite2_GroundTrack,  /* GlgObject */
   Orbit1,                  /* GlgObject */
   Orbit2;                  /* GlgObject */

var
   NumOrbitPoints = 0,  /* int */
   UpdateCount = 0;     /* int */

var
   MapLoaded = false,   /* boolean */
   InitialLoad = true;  /* boolean */

var
   Position1 = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   Position2 = GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

var timer = null;

var gis_request_observer;
   
//////////////////////////////////////////////////////////////////////////////
function StartSatelliteDemo( drawing )
{
   Drawing = drawing;

   InitDrawing();
   
   Drawing.SetupHierarchy();

   Drawing.Update();

   timer = setTimeout( UpdatePosition, UPDATE_INTERVAL );
}

//////////////////////////////////////////////////////////////////////////////
// Initializes satellite icons and orbits.
//////////////////////////////////////////////////////////////////////////////
function InitDrawing()
{
   // Get ID of the GIS object.
   GISObject = Drawing.GetResourceObject( "GISObject" );   
   
   /* Get ID of the GIS Object's GISArray, which holds all icons displayed
      on top of the map in lat/lon coordinates.
   */
   GISArray = GISObject.GetResourceObject( "GISArray" );
   
   // Get IDs of satellite icons.
   Satellite1 = GISArray.GetResourceObject( "Satellite1" );
   Satellite2 = GISArray.GetResourceObject( "Satellite2" );

   Satellite1_GroundTrack =
     GISArray.GetResourceObject( "Satellite1_GroundTrack" );
   Satellite2_GroundTrack =
     GISArray.GetResourceObject( "Satellite2_GroundTrack" );

   /* Get orbit templates and remove them from the drawing initially.
      The templates are polygons with 2 points that store graphical
      attributes of the orbit polygons, to allow user to define the
      attributes interactively via the Graphics Builder. 
      Alternatively, the orbit polygons can be created programmatically.
   */
   Orbit1 = Drawing.GetResourceObject( "Orbit1" );
   Orbit2 = Drawing.GetResourceObject( "Orbit2" );
   Drawing.DeleteThisObject( Orbit1 );
   Drawing.DeleteThisObject( Orbit2 );   

   if( MobileVersion )
     // Increase sliders size for smaller mobile screens.
     Drawing.SetDResource( "SliderScale", 2. );
       
   /* Set the GIS Zoom mode. It was set and saved with the drawing, 
      but do it again programmatically just in case.
   */
   Drawing.SetZoomMode( null, GISObject, null, GLG.GlgZoomMode.GIS_ZOOM_MODE );

   if( MobileVersion )
     Drawing.SetSResource( "UsagePrompt/String",
                           "To rotate the globe,\ntouch and drag or use directional buttons." );
   
   /* Add Input and Trace callbacks used to handle user interaction. */
   Drawing.AddListener( GLG.GlgCallbackType.INPUT_CB, InputCallback );
   Drawing.AddListener( GLG.GlgCallbackType.TRACE_CB, TraceCallback );

   if( USE_REQUEST )
     gis_request_observer =
       GLG.CreateGlgGISRequestObserver( RequestUpdate, RequestAdjustment,
                                        AdjustRequest );
   SetMapLoading( true, null );

   AdjustForMobileDevices();
}

//////////////////////////////////////////////////////////////////////////
// Handle user interaction.
//////////////////////////////////////////////////////////////////////////
function InputCallback( /* GlgObject */ vp, /* GlgObject */ message_obj )
{
   var
     origin,
     format,
     action,
     subaction;
   
   origin = message_obj.GetSResource( "Origin" );
   format = message_obj.GetSResource( "Format" );
   action = message_obj.GetSResource( "Action" );
   subaction = message_obj.GetSResource( "SubAction" );

   if( format == "Button" )         // Handle button clicks
   {
      if( action != "Activate" )
        return;
      
      var gis_center = GISObject.GetGResource( "GISCenter" );  /* GlgPoint */
      var lon = gis_center.x;   /* double */
      var lat = gis_center.y;   /* double */
      
      /* Rotate the globe when a directional button is pressed. */
      if( USE_REQUEST )
      {
         var center_flag = GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER;
         SetMapLoading( true, null );
         
         /* Request a new map via an asynchronous map request. The program
            will continue to operate with the current globe view and will 
            switch to the new globe view when the new map is received and 
            installed via the InstallGISRequest() method.
         */
         if( origin == "Up" )
           GISObject.RequestGISMap( null, 0, 0, lon, lat + ANGLE_DELTA, 0, 0, 
                                    null, center_flag, gis_request_observer );
         else if( origin == "Down" ) 
           GISObject.RequestGISMap( null, 0, 0, lon, lat - ANGLE_DELTA, 0, 0, 
                                    null, center_flag, gis_request_observer );
         else if( origin == "Left" ) 
           GISObject.RequestGISMap( null, 0, 0, lon - ANGLE_DELTA, lat, 0, 0, 
                                    null, center_flag, gis_request_observer );
         else if( origin == "Right" ) 
           GISObject.RequestGISMap( null, 0, 0, lon + ANGLE_DELTA, lat, 0, 0, 
                                    null, center_flag, gis_request_observer );
         else
         {
            SetMapLoading( false, null );
            return;
         }
      }
      else
      {
         /* Set the GIS object's GISCenter directly. The satellite orbits 
            will change to match the new globe view right away, but no map
            will be displayed while the new map is being loaded.
         */
         SetMapLoading( true, null );
         if( origin == "Up" ) 
           GISObject.SetGResource( "GISCenter", lon, lat + ANGLE_DELTA, 0.0 );
         else if( origin == "Down" ) 
           GISObject.SetGResource( "GISCenter", lon, lat - ANGLE_DELTA, 0.0 );
         else if( origin == "Left" ) 
           GISObject.SetGResource( "GISCenter", lon - ANGLE_DELTA, lat, 0.0 );
         else if( origin == "Right" ) 
           GISObject.SetGResource( "GISCenter", lon + ANGLE_DELTA, lat, 0.0 );
         else
         {
            SetMapLoading( false, null );
            return;
         }
      }
        
      Drawing.Update();
   }
   else if( action == "Pan" )
   {
      if( subaction == "Drag" )    // Dragging
      {
         if( !USE_REQUEST && MapLoaded )
           SetMapLoading( true, "Loading map..." );
      }      
      // Dragging ended or aborted (right mouse button, etc.). 
      else if( subaction == "End" || subaction == "Abort" )
      {
         if( subaction != "Abort" )
           SetMapLoading( true, "Loading map..." );
         else
           SetMapLoading( false, null );  // Reset message when dragging ends.

         Drawing.Update();
      }
   }
}

//////////////////////////////////////////////////////////////////////////
// Is used to start globe rotation on a mouse click.
//////////////////////////////////////////////////////////////////////////
function TraceCallback( /* GlgObject */ viewport, /* GlgTraceData */ trace_info )
{      
   var event_type = trace_info.event_type;

   /* Start dragging only on a mouse click in the Drawing area itself,
      not the sliders.
   */
   if( !trace_info.viewport.Equals( Drawing ) )
     return;

   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
      /* Enable touch dragging only for the mobile version to avoid 
         interfering with page scrolling and zooming.
      */
      if( !MobileVersion && !StartDragging )
         return;
      
      GLG.SetTouchMode();        /* Start dragging via touch events. */
      StartDragging = false;     /* Reset for the next time. */
      /* Fall through */

    case GLG.GlgEventType.MOUSE_PRESSED:
      if( trace_info.button == 1 )             /* Start dragging */
      {
         if( USE_REQUEST )
         {
            Drawing.RequestGISZoom( null, 's', 0.0, gis_request_observer );
            SetMapLoading( true, "Release the mouse\nto show the new map." );
         }
         else
           Drawing.SetZoom( null, 's', 0.0 );
      }
      break;
      
    default: return;
   }      
}

//////////////////////////////////////////////////////////////////////////
// Updates moving objects with new position data.
//////////////////////////////////////////////////////////////////////////
function UpdatePosition()
{
   /* If UseRequest=true, the map loading message will be erased when the 
      request is installed.
   */
   if( ( InitialLoad || !USE_REQUEST && !MapLoaded ) &&
       Math.trunc( GISObject.GetDResource( "ImageLoaded" ) ) != 0 )
   {
      SetMapLoading( false, null );
      InitialLoad = false;
   }

   // Obtain new positions for both satellites.
   GetSatellitePosition( 0, Position1 );
   GetSatellitePosition( 1, Position2 );
   
   // Update satellite positions in the drawing with new data.
   Satellite1.SetGResourceFromPoint( "Position", Position1 );
   Satellite2.SetGResourceFromPoint( "Position", Position2 );

   Satellite1_GroundTrack.SetGResource( "Position",
                                        Position1.x, Position1.y, 0.0 );
   Satellite2_GroundTrack.SetGResource( "Position",
                                        Position2.x, Position2.y, 0.0 );
   
   /* Update satellite trajectories. */
   if( NumOrbitPoints <= SAT1_PERIOD || NumOrbitPoints <= SAT2_PERIOD )
   {
      if( NumOrbitPoints == 0 )
      {
         /* First time: add orbit polygons to the GIS Object. 
            Use two points initially, set both points to the same lat/lon.
         */
         SetPolygonPoint( Orbit1, 0, Position1 );
         SetPolygonPoint( Orbit1, 1, Position1 );
         
         // Add to top to draw orbits first, with satellites on top of them.
         GISArray.AddObjectToTop( Orbit1 );
         
         SetPolygonPoint( Orbit2, 0, Position2 ); 
         SetPolygonPoint( Orbit2, 1, Position2 ); 
         GISArray.AddObjectToTop( Orbit2 );

         // Reorder ground tracks to be under the orbit polygons.
         GISArray.DeleteThisObject( Satellite1_GroundTrack );
         GISArray.AddObjectToTop( Satellite1_GroundTrack );

         GISArray.DeleteThisObject( Satellite2_GroundTrack );
         GISArray.AddObjectToTop( Satellite2_GroundTrack );
      }
      else if( NumOrbitPoints == 1 )
      {
         // Set the second point.
         SetPolygonPoint( Orbit1, 1, Position1 );
         SetPolygonPoint( Orbit2, 1, Position2 );
      }
      else
      {
         // Add one more point.
         if( NumOrbitPoints <= SAT1_PERIOD )
           AddPolygonPoint( Orbit1, Position1, true );
         
         if( NumOrbitPoints <= SAT2_PERIOD )
           AddPolygonPoint( Orbit2, Position2, true );
      }
      
      ++NumOrbitPoints; 
   } 
   ++UpdateCount;
   Drawing.Update();
   
   // Restart the update timer
   timer = setTimeout( UpdatePosition, UPDATE_INTERVAL );
}

////////////////////////////////////////////////////////////////////////
// FOR SIMULATION ONLY: Calculates satellite postion (lon, lat and 
// elevation above the Earth in meters) and returns it in the passed
// position parameter.
////////////////////////////////////////////////////////////////////////
function GetSatellitePosition( /* int */ satellite_index,
                               /* GlgPoint */ position )
{
   var rel_value;   /* double */

   switch( satellite_index )
   {
    case 0:
      rel_value = ( UpdateCount % SAT1_PERIOD ) / SAT1_PERIOD;
      position.x = -180.0 + 360.0 * rel_value;
      position.y = 20.0 * Math.sin( 2.0 * Math.PI * rel_value );
      position.z = 1000000.0;
      break;
      
    default:
    case 1:
      rel_value = ( ( 100 + UpdateCount ) % SAT2_PERIOD ) / SAT2_PERIOD;
      position.x = 0.0 + 360.0 * rel_value;
      position.y = 20.0 * Math.sin( 2.0 * Math.PI * rel_value );
      position.z = 1000000.0;
      break;
   }
}

//////////////////////////////////////////////////////////////////////////
function SetPolygonPoint( /* GlgObject */ polygon, /* int */ point_index,
                          /* GlgPoint */ position )
{
   var point;  /* GlgObject */

   point = polygon.GetElement( point_index );
   point.SetGResourceFromPoint( null, position );
}

//////////////////////////////////////////////////////////////////////////
function AddPolygonPoint( /* GlgObject */ polygon, /* GlgPoint */ position,
                          /* boolean */ add_at_the_end )
{
   var point;  /* GlgObject */

   // Copy the first point and add it at the end of the polygon.
   point = polygon.GetElement( 0 );
   point = point.CopyObject();

   point.SetGResourceFromPoint( null, position );
   if( add_at_the_end )
     polygon.AddObjectToBottom( point );
   else                // add at the beginning of the polygon.
     polygon.AddObjectToTop( point );
}

//////////////////////////////////////////////////////////////////////////
function SetMapLoading( /* boolean */ show, /* String */ message )
{
   if( show )
   {
      if( message == null )
        message = "Loading map...";

      Drawing.SetSResource( "LoadingMessage/String", message );
      Drawing.SetDResource( "LoadingMessage/Visibility", 1 );
      MapLoaded = false;
   }
   else
   {
      Drawing.SetDResource( "LoadingMessage/Visibility", 0 );
      MapLoaded = true;
   }
}

//////////////////////////////////////////////////////////////////////////
function EnableTouchDragging()
{
   if( EnableTouchDragging.first_time == undefined )   // first time
   {
       alert( "Scrolling the map by touch-dragging is disabled on this page by default to avoid interfering with page scrolling and zooming on mobile devices. Use the Mobile Version button to see the mobile version with touch scrolling enabled by default.\n\nTo scroll the map on mobile devices by touch on this page, press the Enable Touch Dragging button, then touch and drag the map. To repeat, press the button again." );
      EnableTouchDragging.first_time = false;
   }
   
   StartDragging = true;
}

//////////////////////////////////////////////////////////////////////////////
function AdjustForMobileDevices()
{
   if( CoordScale == 1.0 )
     return;   /* Desktop version. */

   /* Increase size of the satellite icons for mobile devices with increased
      canvas resoltion.
   */
   Satellite1.SetDResource( "MarkerSize", 25. );
   Satellite1_GroundTrack.SetDResource(  "MarkerSize", 15. );

   Satellite2.SetDResource( "MarkerSize", 25. );
   Satellite2_GroundTrack.SetDResource(  "MarkerSize", 15. );
}

//////////////////////////////////////////////////////////////////////////////
// Changes drawing size while maintaining width/height aspect ratio.
//////////////////////////////////////////////////////////////////////////////
function SetDrawingSize( next_size )
{
   const ASPECT_RATIO = 1;

   // Settings for desktop displays.
   const MIN_WIDTH = 400;
   const MAX_WIDTH = 1000;
   const SCROLLBAR_WIDTH = 15;
   
   if( SetDrawingSize.size_index == undefined )   // first time
   {
      SetDrawingSize.size_index = 0;

      SetDrawingSize.small_sizes       = [ 1, 1.5,  2.,   2.5 ];
      SetDrawingSize.medium_sizes      = [ 1, 0.75, 1.25, 1.5 ];
      SetDrawingSize.large_sizes       = [ 1, 0.6,  1.25, 1.5 ];
      SetDrawingSize.num_sizes = SetDrawingSize.small_sizes.length;
      SetDrawingSize.is_mobile = ( screen.width <= 760 );

      window.addEventListener( "resize", ()=>{ SetDrawingSize( false ) } );
   }
   else if( next_size )
   {
      ++SetDrawingSize.size_index;
      SetDrawingSize.size_index %= SetDrawingSize.num_sizes;
   }

   var drawing_area = document.getElementById( "glg_area" );
   if( SetDrawingSize.is_mobile )
   {
      /* Mobile devices use constant device-width, adjust only the height 
         of the drawing to keep the aspect ratio.
      */
      drawing_area.style.height =
        "" + Math.trunc( drawing_area.clientWidth / ASPECT_RATIO ) + "px";
   }
   else   /* Desktop */
   {
      var span = document.body.clientWidth; 
      if( !SetDrawingSize.is_mobile )
        span -= SCROLLBAR_WIDTH;

      var start_width;
      if( span < MIN_WIDTH )
        start_width = MIN_WIDTH;
      else if( span > MAX_WIDTH )
        start_width = MAX_WIDTH;
      else
        start_width = span;

      var size_array;
      if( span < 600 )
        size_array = SetDrawingSize.small_sizes;
      else if( span < 800 )
        size_array = SetDrawingSize.medium_sizes;
      else
        size_array = SetDrawingSize.large_sizes;

      var size_coeff = size_array[ SetDrawingSize.size_index ];
      var width = Math.trunc( Math.max( start_width * size_coeff, MIN_WIDTH ) );
   
      drawing_area.style.width = "" + width + "px";
      drawing_area.style.height = "" + Math.trunc( width / ASPECT_RATIO ) + "px";
   }
}

//////////////////////////////////////////////////////////////////////////////
// Increases canvas resolution for mobile devices with HiDPI displays.
// Returns chosen coordinate scale factor.
//////////////////////////////////////////////////////////////////////////////
function SetCanvasResolution()
{
   // Set canvas resolution only for mobile devices with devicePixelRatio != 1.
   if( window.devicePixelRatio == 1. || !SetDrawingSize.is_mobile )
     return 1.0;   // Use coord scale = 1.0 for desktop.
   
   /* The first parameter defines canvas coordinate scaling with values 
      between 1 and devicePixelRatio. Values greater than 1 increase 
      canvas resolution and result in sharper rendering. The value of 
      devicePixelRatio may be used for very crisp rendering with very thin lines.

      Canvas scale > 1 makes text smaller, and the second parameter defines
      the text scaling factor used to increase text size.

      The third parameter defines the scaling factor that is used to
      scale down text in native widgets (such as native buttons, toggles, etc.)
      to match the scale of the drawing.
   */
   var coord_scale = 2.0;
   GLG.SetCanvasScale( coord_scale, 1.75, 0.6 );
   
   // Mobile devices use fixed device-width: disable Change Drawing Size button.
   var change_size_button = document.getElementById( "change_size" );
   if( change_size_button != null )
     change_size_button.parentNode.removeChild( change_size_button );

   return coord_scale;      // Chosen coord scale for mobile devices.
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface, requests no adjustement callbacks.
//////////////////////////////////////////////////////////////////////////
function RequestAdjustment()
{
   return false;
}
//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: adjustement callback.
//////////////////////////////////////////////////////////////////////////
function AdjustRequest( /* GlgGISRequestData */ request_data )
{
   return false;
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: receives status update notifications.
//////////////////////////////////////////////////////////////////////////
function RequestUpdate( /* GlgObject */ gis_object, status )
{
   switch( status )
   {
    case GLG.GlgGISRequestStatus.GIS_REQUEST_READY:
      if( GISObject.InstallGISRequest( null ) )
        Drawing.Update();
      else
        console.log( "Failed to install map request." );
      break;
      
    default:
      console.log( "Aborting previous GIS request." ); 
      break;
   }

   SetMapLoading( false );
}
