/***************************************************************************
  This example demonstrates how to display and update a GLG realtime
  stripchart widget and use its integrated interactive behavior.

  GlgChart class is derived from GlgJBean and encapsulates methods
  for initializing the chart, updating the chart with data and handling
  user interaction. 

  GlgChart loads and displays a drawing passed as an argument to the 
  LoadDrawing() method. It is expected that the drawing includes a 
  viewport named ChartViewport as well as interface widgets allowing 
  to scroll and zoom the chart. ChartViewport contains the Chart object 
  which plots the chart data.
  
  The chart is initilaized in the H and V callbacks and updated with 
  data supplied by the DataFeed using a timer. The demo uses DemoDataFeed
  to generate simulated data. The application will provide a custom
  data feed implementation via LiveDataFeed class. Both DemoDataFeed
  and LiveDataFeed implement DataFeedInterface.

  The X axis labels display current date and time using the time format
  defined in the drawing. Data points in the chart are positioned according
  to their time stamp. An application may provide a time stamp for each 
  data point, otherwise the chart will automatically use current time for 
  the time stamp.

  This example is written using GLG Intermediate API.
 ***************************************************************************/

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.lang.reflect.*;
import java.util.ArrayList;
import com.genlogic.*;

//////////////////////////////////////////////////////////////////////////
public class GlgChart extends GlgJBean implements ActionListener
{
   static final long serialVersionUID = 0;

   /* RandomData is set to true to use simulated data for animation, 
      and false for live real-time data. In the demo, RandomData is assigned 
      by the parent container, using RANDOM_DATA flag or command 
      line option -random-data or live-data. 
    */
   public boolean RandomData = true;

   // Parent container.
   GlgRTChartExample ParentContainer;
   
   /* If set to true, the application supplies time stamp for each data 
      sample explicitly in DataFeed.GetPlotPoint(). Otherwise, time stamp 
      is automatically generated by the chart using current time.
   */
   public boolean SUPPLY_TIME_STAMP = false;
 
   // Chart orientation - HORIZONTAL or VERTICAL.                       
   int ChartOrientation;

   // DataFeed object is used to supply data for animation.
   DataFeedInterface DataFeed;

   Timer timer = null;                // Timer for periodic updates. 
   int UpdateInterval = 100;          // Update interval in msec.

   // Number of lines and Y axes in a chart as defined in the drawing.
   int NumPlots;
   int NumYAxes;

   GlgObject ChartVP;    // ChartViewport
   GlgObject Chart;      // Chart object inside ChartViewport

   /* Store object IDs for each plot. 
      Used for performance optimization to update the chart with data.
   */
   GlgObject [] Plots;
  
   /* Store Low and High ranges of each Y axis in the drawing.
      It is assumed that each plot is linked to a Y axis in the drawing, 
      so the plot's  Low and High is set automatically based on 
      the linked Y axis.
   */
   double [] Low;
   double [] High;

   boolean IsReady = false;
 
   /* Convenient time span constants. */
   static final int ONE_MINUTE = 60;
   static final int ONE_HOUR   = 3600;
   static final int ONE_DAY    = 3600 * 24;

   /* Prefill time interval, specifies amount of data to prefill in the 
      real time chart. 
   */
   final int PREFILL_SPAN = ONE_HOUR;

   final double TIME_SPAN = ONE_MINUTE;       // Time axis span in sec.
   final double SCROLL_INCREMENT = 10.;       // Scroll increment in sec.

   // Scroll factor for the X axis. 
   final double ScrollFactor = SCROLL_INCREMENT / TIME_SPAN;

   boolean PrefillData = true;     /* Setting to False suppresses pre-filling 
                                      the  chart's buffer with data 
                                      on start-up. */
   int AutoScroll = 1;             /* Current auto-scroll state: enabled(1) or 
                                      disabled(0). */
   int StoredScrollState;          /* Stored AutoScroll state to be restored 
                                      if ZoomTo is aborted. */


   // Used by DataFeed to return data values.
   DataPoint data_point = new DataPoint();
    
   /////////////////////////////////////////////////////////////////////
   // Constructor.
   /////////////////////////////////////////////////////////////////////
   public GlgChart( GlgRTChartExample parent )
   {
      ParentContainer = parent;

      /* Activate Trace callback. In this example, it is used
         to activate chart scrolling by dragging it with the mouse.
      */
      AddListener( GlgObject.TRACE_CB, this );

      /* Disable automatic update for input events to avoid slowing down 
         real-time chart updates.
      */
      SetAutoUpdateOnInput( false );
   }
   
   /////////////////////////////////////////////////////////////////////
   // Add DataFeed object for supplying chart data.
   /////////////////////////////////////////////////////////////////////
   public void AddDataFeed()
   {
      if( RandomData )
      {
         DataFeed = new DemoDataFeed( this );
         error( "Using DemoDataFeed.", false );
      }
      else
      {
         DataFeed = new LiveDataFeed( this );
         error( "Using LiveDataFeed.", false );
      }
   }
   
   //////////////////////////////////////////////////////////////////////
   // Load a specified GLG drawing.
   //////////////////////////////////////////////////////////////////////
   public void LoadDrawing( String drawing_name )
   {
      if( drawing_name == null )
      {
         System.out.println( "No drawing file: drawing loading failed." );
         return;
      }

      SetDrawingName( drawing_name );
   }

   //////////////////////////////////////////////////////////////////////
   // Creates timer to perform periodic data updates.
   /////////////////////////////////////////////////////////////////////
   public void StartUpdates()
   {
      if( timer == null )
      {
         timer = new Timer( UpdateInterval, this );
         timer.setRepeats( false );
         timer.start();
      }
   }

   ///////////////////////////////////////////////////////////////////////
   // Stops periodic updates.
   ///////////////////////////////////////////////////////////////////////
   public void StopUpdates()
   {
      if( timer != null )
      {
         timer.stop();
         timer = null;
      }

      // Disable dynamic updates of the drawing
      IsReady = false;
   }

   ////////////////////////////////////////////////////////////////////////
   // HCallback is invoked after the Glg drawing is loaded, but before the 
   // hierarchy setup takes place and before the drawing is drawn for the 
   // first time. 
   ////////////////////////////////////////////////////////////////////////
   public void HCallback( GlgObject viewport )
   {
      double major_interval, minor_interval;

      ChartVP = viewport.GetResourceObject( "ChartViewport" );
      if( ChartVP == null )
        GlgObject.Error( GlgObject.USER_ERROR,
                         "Can't find ChartViewport", null );

      Chart = ChartVP.GetResourceObject( "Chart" );
      if( Chart == null )
        GlgObject.Error( GlgObject.USER_ERROR,
                         "Can't find Chart object", null );

      // Retrieve the chart orientation, i.e. vertical or horizontal.
      ChartOrientation = Chart.GetDResource( "Orientation" ).intValue();

      // Retrieve number of plots defined in .g file.
      NumPlots = Chart.GetDResource( "NumPlots" ).intValue();

      // Retrieve number of Y axes defined in .g file.
      NumYAxes = Chart.GetDResource( "NumYAxes" ).intValue();
      
      // Set Time Span for the X axis.
      Chart.SetDResource( "XAxis/Span", TIME_SPAN );
      
      /* Set tick intervals for the Time axis.
         Use positive values for absolute time interval, for example
         set major_interval = 10 for a major tick every 10 sec.
      */
      major_interval = -6;      // 6 major intervals
      minor_interval = -5;      // 5 minor intervals
      Chart.SetDResource( "XAxis/MajorInterval", major_interval );
      Chart.SetDResource( "XAxis/MinorInterval", minor_interval );
      
      // Enable AutoScroll, both for the toggle button and the chart.
      ChangeAutoScroll( 1 );

      // Set Chart Zoom mode. It was set and saved with the drawing, 
      // but do it again programmatically just in case.
      //
      ChartVP.SetZoomMode( null, Chart, null, GlgObject.CHART_ZOOM_MODE );
   }
   
   //////////////////////////////////////////////////////////////////////
   // VCallback() is invoked after the drawing is loaded and setup, 
   // but before it is drawn for the first time. 
   /////////////////////////////////////////////////////////////////////
   public void VCallback( GlgObject viewport )
   {
      int i;

      // Store objects IDs for each plot.
      Plots = new GlgObject[ NumPlots ];

      GlgObject plot_array = Chart.GetResourceObject( "Plots" );
      for( i=0; i<NumPlots; ++i )
      {
         Plots[ i ] = (GlgObject) plot_array.GetElement( i ); 

         /* If needed, set EdgeColor and Annotation for each plot:
            Plots[i].SetGResource( "EdgeColor", r, g, b );
            Plots[i].SetSResource( "Annotation", annotation_string );
         */
      }

      /* Store initial range for each Y axis, used to restore ranges
         on zoom reset. Assumes that each plot is linked to the 
         corresponding axis in the drawing.
      */         
      Low = new double[ NumYAxes ];
      High = new double[ NumYAxes ];

      GlgObject axis_array = Chart.GetResourceObject( "YAxisGroup" );
      for( i=0; i<NumYAxes; ++i )
      {
         GlgObject axis = (GlgObject) axis_array.GetElement( i ); 
         Low[ i ] = axis.GetDResource( "Low" ).doubleValue();
         High[ i ] = axis.GetDResource( "High" ).doubleValue();
      }
   }
   
   ////////////////////////////////////////////////////////////////////////
   // ReadyCallback is invoked after the drawing is loaded, setup and 
   // initially drawn.
   ////////////////////////////////////////////////////////////////////////
   public void ReadyCallback( GlgObject viewport )
   {
      IsReady = true;

      /* Add DataFeed object used to supply chart data.
         The example uses demo data. To supply application specific
         data, replace DemoDataFeed with a custom LiveDataFeed.
      */
      AddDataFeed();

      // Prefill chart's history buffer with data. 
      if( PrefillData )
        FillChartHistory();
   }

   ///////////////////////////////////////////////////////////////////////
   // ActionListener for timer, invoked periodically with 
   // time interval = UpdateInterval.
   //////////////////////////////////////////////////////////////////////
   public void actionPerformed( ActionEvent e )
   {
      if( timer == null )
        return;                 // Prevents race conditions.

      UpdateChart();            // Update the chart with nre data.
      
      timer.start();            // Restart the timer. 
   }

   ///////////////////////////////////////////////////////////////////////
   // Push new data values to all lines in the chart.
   // Invoked periodically by timer with time interval defined by
   // UpdateInterval.
   ///////////////////////////////////////////////////////////////////////
   public void UpdateChart()
   {
      /* Perform dynamic updates only if the drawing is ready and 
         the timer is active.
      */
      if( !IsReady )
         return;
      
      // Update plot lines with new data supplied by the DataFeed object.
      for( int i=0; i<NumPlots; ++i )
      {
         /* Use DataFeed to get new data value. The DataFeed object
            fills the data_point object with value, time_stamp, etc.
         */
         if( DataFeed.GetPlotPoint( i, data_point ) )
           PushPlotPoint( Plots[ i ], data_point );
         else
           error( "Error getting plot data sample.", false );
      }

      Update(); // Refresh display.
   }

   ///////////////////////////////////////////////////////////////////////
   // Pushes the data_point's data into the plot.
   ///////////////////////////////////////////////////////////////////////
   public void PushPlotPoint( GlgObject plot, DataPoint data_point )
   {
      // Supply plot value for the chart via ValueEntryPoint.
      plot.SetDResource( "ValueEntryPoint", data_point.value );
                 
      if( data_point.time_stamp != 0 )
      {
         /* Supply an optional time stamp. If not supplied, the chart will 
            automatically generate a time stamp using current time. 
         */
         plot.SetDResource( "TimeEntryPoint", data_point.time_stamp );
      }
      
      if( !data_point.value_valid )
      {	   
         /* If the data point is not valid, set ValidEntryPoint resource to 
            display holes for invalid data points. If the point is valid,
            it is automatically set to 1. by the chart.
         */
         plot.SetDResource( "ValidEntryPoint", 0. );
      }
   }
      
   /////////////////////////////////////////////////////////////////////// 
   // Pre-fill the graph's history buffer with data. 
   /////////////////////////////////////////////////////////////////////// 
   public void FillChartHistory()
   {
      double current_time = GetCurrTime();
      
      /* Fill the amount of data requested by the PREFILL_SPAN, up to the 
         available chart's buffer size defined in the drawing.
         Add an extra second to avoid rounding errors.
      */
      int num_seconds = PREFILL_SPAN + 1;

      int buffer_size = Chart.GetDResource( "BufferSize" ).intValue();
      if( buffer_size < 1 )
        buffer_size = 1;
      
      int max_num_samples;
      if( RandomData )
      {
         /* In random demo data mode, simulate data stored once per second. */
         double samples_per_second = 1.0;
         max_num_samples = (int) ( num_seconds * samples_per_second );

         if( max_num_samples > buffer_size )
           max_num_samples = buffer_size;
      }
      else
        max_num_samples = buffer_size;

      double start_time = current_time - num_seconds;
      double end_time = current_time;   /* Stop at the current time. */

      for( int i=0; i<NumPlots; ++i )
      { 
         ArrayList<DataPoint> data_array = 
           DataFeed.GetHistPlotData( i, start_time, end_time,
                                     max_num_samples );

         if( data_array == null || data_array.isEmpty() )
         {
            error( "No historical data for plot_index = " + i, false );
            continue;
         }

         FillPlotData( Plots[ i ], data_array );
      }
   }
   
   /////////////////////////////////////////////////////////////////////// 
   // Fills plot with data from the provided data array.
   /////////////////////////////////////////////////////////////////////// 
   public void FillPlotData( GlgObject plot,
                             ArrayList<DataPoint> data_array )
   {   
      int size = data_array.size();
      for( int i=0; i<size; ++i )
      {
         DataPoint data_point = data_array.get( i );
         PushPlotPoint( plot, data_point );
      }
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Handle user interaction.
   ///////////////////////////////////////////////////////////////////////
   public void InputCallback( GlgObject viewport, GlgObject message_obj )
   {
      String
        origin,
        format,
        action,
        subaction;
      
      origin = message_obj.GetSResource( "Origin" );
      format = message_obj.GetSResource( "Format" );
      action = message_obj.GetSResource( "Action" );
      subaction = message_obj.GetSResource( "SubAction" );
      
      // Handle window closing if run stand-alone. 
      if( format.equals( "Window" ) && action.equals( "DeleteWindow" ) )
        System.exit( 0 );
      
      // Process button events.
      if( format.equals( "Button" ) )   
      {
         if( !action.equals( "Activate" ) &&      /* Not a push button */
             !action.equals( "ValueChanged" ) )   /* Not a toggle button */
           return;
         
         AbortZoomTo();
         
         if( origin.equals( "ToggleAutoScroll" ) )
         {         
            // Set Chart AutoScroll based on the 
            // ToggleAutoScroll toggle button setting.
            ChangeAutoScroll( -1 ); 
         }
         else if( origin.equals( "ZoomTo" ) )
         {
            // Start ZoomTo operation.
            ChartVP.SetZoom( null, 't', 0. );  
         }
         else if( origin.equals( "ResetZoom" ) )
         {         
            // Set initial time span and reset initial Y ranges.
            SetChartSpan( TIME_SPAN );  
            RestoreInitialYRanges();   
         }
         else if( origin.equals( "ScrollBack" ) )
         {
            ChangeAutoScroll( 0 );
            
            /* Scroll left (horizontal chart) or scroll down (vertical chart). 
               Scrolling can be done by either setting chart's 
               XAxis/EndValue resource or by using GlgSetZoom().
            */
            
            /* double end_value;
               double end_value = 
                   Chart.GetDResource( "XAxis/EndValue" ); 
               end_value -= SCROLL_INCREMENT;
               Chart.SetDResource( "XAxis/EndValue", end_value );
            */
            
            switch( ChartOrientation )
            {
             case GlgObject.HORIZONTAL:
             default:
               ChartVP.SetZoom( null, 'l', ScrollFactor );
               break;
             case GlgObject.VERTICAL:
               ChartVP.SetZoom( null, 'd', ScrollFactor );
               break;
            }
         }
         else if( origin.equals( "ScrollForward" ) )
         {
            ChangeAutoScroll( 0 );

            switch( ChartOrientation )
            {
             case GlgObject.HORIZONTAL:
             default:
               // Scroll right.
               ChartVP.SetZoom( null, 'r', ScrollFactor );
               break;
             case GlgObject.VERTICAL:
               // Scroll up.
               ChartVP.SetZoom( null, 'u', ScrollFactor );
               break;
            }
         }
         else if( origin.equals( "ScrollToRecent" ) )
         {
            // Scroll to show most recent data.
            ScrollToDataEnd();
         }
         
         Update();
      }
      else if( format.equals( "Chart" ) && 
               action.equals( "CrossHairUpdate" ) )
      {
         /* To avoid slowing down real-time chart updates, invoke Update() 
            to redraw cross-hair only if the chart is not updated fast 
            enough by the timer.
         */
         if( UpdateInterval > 100 )
           Update();
      }            
      else if( action.equals( "Zoom" ) )    // Zoom events
      {
         if( subaction.equals( "ZoomRectangle" ) )
         {
            // Store AutoSCroll state to restore it if ZoomTo is aborted.
            StoredScrollState = AutoScroll;
            
            // Stop scrolling when ZoomTo action is started.
            ChangeAutoScroll( 0 );
         }
         else if( subaction.equals( "End" ) )
         {
            /* No additional actions on finishing ZoomTo. The Value axis 
               scrollbar appears automatically if needed: 
               it is set to PAN_Y_AUTO for a horizontal chart
               and PAN_X_AUTO for a vertical chart.
               Don't resume scrolling: it'll scroll too fast since we zoomed 
               in. Keep it still to allow inspecting zoomed data.
            */
         }
         else if( subaction.equals( "Abort" ) )
         {
            // Resume scrolling if it was on.
            ChangeAutoScroll( StoredScrollState ); 
         }
         
         Update();
      }
      else if( action.equals( "Pan" ) )    // Pan events
      {
         // This code may be used to perform custom action when dragging the 
         // chart's data with the mouse. 
         if( subaction.equals("Start" ) )   // Chart dragging start
         {
         }
         else if( subaction.equals( "Drag" ) )    // Dragging
         {
         }
         else if( subaction.equals( "ValueChanged" ) )   // Scrollbars
         {
         }
         /* Dragging ended or aborted. */
         else if( subaction.equals( "End" ) || 
                  subaction.equals( "Abort" ) )
         {
         }     
      }   
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Scroll to the end of the data history buffer.
   ///////////////////////////////////////////////////////////////////////
   public void ScrollToDataEnd()
   {
      GlgMinMax min_max = Chart.GetDataExtent( null, true /* x extent */ );
      if( min_max == null )
        return;
      
      Chart.SetDResource( "XAxis/EndValue", min_max.max );
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Change chart's AutoScroll mode.
   ///////////////////////////////////////////////////////////////////////
   public void ChangeAutoScroll( int new_value )
   {
      if( new_value == -1 )  // Use the state of the ToggleAutoScroll button.
      {
         double auto_scroll = 
           GetDResource( "Toolbar/ToggleAutoScroll/OnState" );
         AutoScroll = (int) auto_scroll;
      }
      else    // Set to the supplied value. 
      {
         AutoScroll = new_value;
         SetDResource( "Toolbar/ToggleAutoScroll/OnState", 
                       (double) AutoScroll );
      }
      
      // Set chart's auto-scroll.
      Chart.SetDResource( "AutoScroll", (double) AutoScroll );
      
      /* Activate time scrollbar if AutoScroll is Off. The Value scrollbar 
         uses PAN_Y_AUTO (horizontal chart) or PAN_X_AUTO (vertical chart) 
         and appears automatically as needed.
      */
      int pan_time_axis, pan_value_axis;
      switch( ChartOrientation )
      {
       case GlgObject.HORIZONTAL:
       default:
         pan_time_axis = GlgObject.PAN_X;
         pan_value_axis = GlgObject.PAN_Y_AUTO;
         break;
       case GlgObject.VERTICAL:
         pan_time_axis = GlgObject.PAN_Y;
         pan_value_axis = GlgObject.PAN_X_AUTO;
         break;
      }

      pan_time_axis = ( AutoScroll != 0 ? GlgObject.NO_PAN : pan_time_axis );
      ChartVP.SetDResource( "Pan", (double) ( pan_time_axis | pan_value_axis ) );
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Changes the time span shown in the graph.
   ///////////////////////////////////////////////////////////////////////
   public void SetChartSpan( double span )
   {
      if( span > 0 )
        Chart.SetDResource( "XAxis/Span", span );
      else  // Reset span to show all data accumulated in the buffer.
        ChartVP.SetZoom( null, 'N', 0. );
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Restore Y axis range to the initial Low/High values.
   ///////////////////////////////////////////////////////////////////////
   public void RestoreInitialYRanges()
   {
      GlgObject axis_array = Chart.GetResourceObject( "YAxisGroup" );
      for( int i=0; i<NumYAxes; ++i )
      {
         GlgObject axis = (GlgObject) axis_array.GetElement( i ); 
         axis.SetDResource( "Low", Low[ i ] );
         axis.SetDResource( "High", High[ i ] );
      }
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Returns True if the chart's viewport is in ZoomToMode.
   // ZoomToMode is activated on Dragging and ZoomTo operations.
   ///////////////////////////////////////////////////////////////////////
   public boolean ZoomToMode()
   {
      int zoom_mode = ChartVP.GetDResource( "ZoomToMode" ).intValue();
      return ( zoom_mode != 0 );
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Abort ZoomTo mode.
   ///////////////////////////////////////////////////////////////////////
   public void AbortZoomTo()
   {
      if( ZoomToMode() )
      {
         // Abort zoom mode in progress.
         ChartVP.SetZoom( null, 'e', 0. ); 
         Update();
      }
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Used to obtain coordinates of the mouse click.
   ///////////////////////////////////////////////////////////////////////
   public void TraceCallback( GlgObject viewport, GlgTraceData trace_info )
   {
      if( !IsReady )
        return;
      
      // Process only events that occur in ChartVP.
      if( trace_info.viewport != ChartVP )
        return;
      
      int event_type = trace_info.event.getID();
      switch( event_type )
      {
       case MouseEvent.MOUSE_PRESSED:
       case MouseEvent.MOUSE_MOVED:
       case MouseEvent.MOUSE_DRAGGED:
         /* The code to get the mouse coordinates if needed:
            x = ((MouseEvent)trace_info.event).getX();
            y = ((MouseEvent)trace_info.event).getY();
         */
         break;
         
       default: return;
      }
      
      switch( event_type )
      {
       case MouseEvent.MOUSE_PRESSED:
         if( ZoomToMode() )
           return; // ZoomTo or dragging mode in progress.
         
         /* Start dragging with the mouse on a mouse click. 
            If user clicked of an axis, the dragging will be activated in the
            direction of that axis. If the user clicked in the chart area,
            dragging in both the time and the Y direction will be activated.
         */
         ChartVP.SetZoom( null, 's', 0. );
         
         // Disable AutoScroll not to interfere with dragging.
         ChangeAutoScroll( 0 ); 
         break;
         
       default: return;
      }
   }
   
   /////////////////////////////////////////////////////////////////////// 
   // Return exact time including fractions of seconds.
   /////////////////////////////////////////////////////////////////////// 
   public double GetCurrTime()
   {
      return System.currentTimeMillis() / 1000.;
   }

   /////////////////////////////////////////////////////////////////////// 
   void error( String string, boolean quit )
   {
      System.out.println( string );
      if( quit )
         System.exit( 0 );
   }

   //////////////////////////////////////////////////////////////////////////
   // Invoked by the browser asynchronously to stop the applet.
   // This method is provided in case the class is used as an applet;
   // it is not used when it is used as a bean in a parent applet in this 
   // example.
   //////////////////////////////////////////////////////////////////////////
   public void stop()
   {
      StopUpdates();

      // GlgJBean handles asynchronous invocation when used as an applet.
      super.stop();
   }
}
