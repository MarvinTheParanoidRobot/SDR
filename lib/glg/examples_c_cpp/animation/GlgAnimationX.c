/*----------------------------------------------------------------------
| This example demonstrates how to load a GLG drawing and update
| its dynamic attributes periodically, as well as handle object
| selection with the mouse. The program exits when user clicks 
| on a moving object.
|
| Periodic dynamic updates are handled in the Update procedure, which
| is invoked when a specified time interval elapses. It is registered
| as a Timer procedure using GlgAddTimeOut function with a specified
| time interval.
|
| Object selection event is handled in the Select callback.
|
| The "animation.g" drawing contains a ball named "CatchMe" and a polygon
| named "Area". The lower left and upper right control points of the area
| polygon are named "LLPoint" and "URPoint". The program queries the 
| coordinates of these control points and uses them to animate the ball
| by moving it inside the area. The ball has X and Y move transformations
| attached to it to control its position. The program sets the XValue 
| and YValue parameters of the transformations to move the ball.
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>

#include "GlgWrapper.h"

/* Set this defined constant to be 1 to use code generated by the
 * GLG Code Generation Utility. Save the drawing uncompressed to 
 * generate code.
 */
#define USE_GENERATED_CODE     0

#define WIDTH     600
#define HEIGHT    600

void Input( Widget widget, XtPointer client_data, XtPointer call_data );
void Select( Widget widget, XtPointer client_data, XtPointer call_data );
void VInit( Widget widget, XtPointer client_data, XtPointer call_data );
void Update( Widget widget, XtIntervalId *timer_id );
void GetNewPosition( double *x_pos, double *y_pos );

#if USE_GENERATED_CODE
/* The following symbols should be defined in the file generated by the
 * GLG Code Generation Utility.
 */
extern long AnimationData[];
extern long AnimationDataSize;
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950
#endif

/* Global animation parameters. */
#define DELTA     ( 2. * M_PI / 500. )

double XIncrement = DELTA * 8.;
double YIncrement = DELTA * 7.;

/* Time interval for periodic dynamic updates, in millisec. */
unsigned int TimeInterval = 20; 

double Radius;   /* Moving ball's radius */
double
  XMin, XMax,    /* Ball movement's area */
  YMin, YMax;

XtAppContext AppContext;

/*----------------------------------------------------------------------
|
*/
int main( argc, argv )
     int argc;
     char *argv[];
{
   Display * display;
   Widget shell, glgWrapper;
   GlgObject viewport;
   Cardinal ac;
   Arg al[20];
   double z;
   
   /* Initialize X Toolkit and create an application context. */
   XtToolkitInitialize();
   AppContext = XtCreateApplicationContext();
   
   /* Open a display connection. */
   display = XtOpenDisplay( AppContext, NULL, "GlgAnimation", "Glg",
			   0, 0, &argc, argv );
   
   /* Create a shell */
   ac = 0;
   XtSetArg( al[ac], XtNbaseWidth, WIDTH ); ac++;
   XtSetArg( al[ac], XtNbaseHeight, HEIGHT ); ac++;
   XtSetArg( al[ac], XtNwidth, WIDTH ); ac++;
   XtSetArg( al[ac], XtNheight, HEIGHT ); ac++;
   XtSetArg( al[ac], XtNminWidth, 10 ); ac++;
   XtSetArg( al[ac], XtNminHeight, 10 ); ac++;
   XtSetArg( al[ac], XtNallowShellResize, True ); ac++;
   XtSetArg( al[ac], XtNinput, TRUE ); ac++;
   shell =
     XtAppCreateShell( "GlgAnimation", "Glg", applicationShellWidgetClass,
		      display, al, ac );
   
   /* Create a GLG widget. */
   ac = 0;
   
   /* Specify a drawing to use, either from a file or a generated image. */
#if USE_GENERATED_CODE
   /* Use a generated drawing image. */
   XtSetArg( al[ac], XtNglgDrawingImage, AnimationData ); ac++;
   XtSetArg( al[ac], XtNglgImageSize, AnimationDataSize ); ac++;
#else
   /* Take the drawing from a file. */
   XtSetArg( al[ac], XtNglgDrawingFile, "animation.g" ); ac++;
#endif
   
   /* Create an instance of a GLG Wrapper widget. */
   glgWrapper =
     XtCreateWidget( "GlgWrapper", glgWrapperWidgetClass, shell, al, ac );

   /* Add callbacks to handle user interaction in the GLG objects. 
      Select callback is invoked when the user selects a graphical 
      object with the mouse, such as a ball. Input callback is invoked
      when the user selects a GLG input object, such as a button.
   */
   XtAddCallback( glgWrapper, XtNglgSelectCB, Select, NULL );
   XtAddCallback( glgWrapper, XtNglgInputCB, Input, NULL );
   
   /* Add a callback to initialize or query parameters of a GLG
      drawing. */
   XtAddCallback( glgWrapper, XtNglgVInitCB, VInit, NULL );

   XtManageChild( glgWrapper );    
   XtRealizeWidget( shell );
   
   /* Add a work procedure to update the animation. */
   XtAppAddTimeOut( AppContext, TimeInterval,
		    (XtTimerCallbackProc)Update, (XtPointer)glgWrapper );
   
   XtAppMainLoop( AppContext );
}

/*----------------------------------------------------------------------
| Animates the ball by moving it inside the area defined in the drawing.
*/
void Update( widget, timer_id )
     Widget widget;
     XtIntervalId *timer_id;
{
   GlgObject viewport;
   double x_pos, y_pos; 

   viewport = XglgGetWidgetViewport( widget );

   /* Calculate new coordinates of the ball. */
   GetNewPosition( &x_pos, &y_pos );

   /* Increment the path animation resource. */
   XglgSetDResource( viewport, "CatchMe/XValue", x_pos );
   XglgSetDResource( viewport, "CatchMe/YValue", y_pos );

   XglgUpdate( viewport );    /* Makes changes visible. */

   /* Improves interactive response. */
   XSync( XtDisplay( widget ), False );

   /* Reinstall the timeout to continue updating */
   XtAppAddTimeOut( AppContext, TimeInterval,
		    (XtTimerCallbackProc)Update, (XtPointer)widget );
   
}

/*----------------------------------------------------------------------
|  Value Initialization callback, VInit. It is invoked after the 
|  drawing is loaded and object hierarchy is set up, but before
|  it is painted for the first time. It may be used to initialize
|  or query drawing parameters. 
|
|  Unlike VInit callback, another type of initialization callback,
|  HInit callback, is invoked BEFORE object hierarchy is set up.
*/ 
void VInit( widget, client_data, call_data )
   Widget widget;
   GlgAnyType client_data;
   GlgAnyType call_data;
{
   GlgObject viewport;
   double z;

   /* Retrieve GLG viewport object from  the wrapper widget. */
   viewport = XglgGetWidgetViewport( widget );

   /* Query the ball's radius. */
   XglgGetDResource( viewport, "CatchMe/Radius", &Radius );

   /* Query the extent of the ball's movement area. */
   XglgGetGResource( viewport, "Area/LLPoint", &XMin, &YMin, &z );
   XglgGetGResource( viewport, "Area/URPoint", &XMax, &YMax, &z );
}


/*----------------------------------------------------------------------
| This callback is invoked when user selects some object in the drawing
| with the mouse. In this program, it's used to exit animation if
| user selects the moving object (named "CatchMe").
*/
void Select( widget, client_data, call_data )
     Widget widget;
     XtPointer client_data;
     XtPointer call_data;
{
   GlgObject viewport;
   char ** name_array;
   char * name;
   int i, j;

   name_array = (char **) call_data;
   viewport = XglgGetWidgetViewport( widget );

   if( name_array )    /* Something was selected. */
   {
      for( i=0; name = name_array[ i ]; ++i )
	if( strcmp( name, "Faster" ) == 0 || strcmp( name, "Slower" ) == 0 )
	  /* Ignore buttons selection */
	  return;   

      for( i=0; name = name_array[ i ]; ++i )
	if( strcmp( name, "CatchMe" ) == 0 )
	{
	   /* Got the moving object: blink three times and exit. */
	   for( j=0; j<6; ++j )
	   {
	      /* Change the index of the color dynamics attached to the
	       * object's FillColor attribute from 0 to 1 and back to blink.
	       * You can check it in the editor by selecting the FillColor 
	       * attribute of the object and clicking on the Edit Dynamics 
	       * button in the Attribute Dialog.
	       */
	      XglgSetDResource( viewport, "CatchMe/ColorIndex",
			       ( j % 2 ) ? 1. : 0. );
	      XglgUpdate( viewport );
	      GlgSleep( 100 );   /* Delay for 0.1 sec */
	   }
	   exit( 0 );
	}
   }
	  
   GlgBell( XglgGetWidgetViewport( widget ) );   /* Missed: beep'em up! */
}

/*----------------------------------------------------------------------
| This callback is invoked when user interacts with input objects in GLG
| drawing. In this program, it is used to increase or decrease the animation
| speed.
*/
void Input( widget, client_data, call_data )
     Widget widget;
     XtPointer client_data;
     XtPointer call_data;
{
   GlgObject
     message_obj,
     viewport;
   char
     * format,
     * action,
     * origin;
      
   message_obj = (GlgObject) call_data;

   /* Get the message's format, action and origin. */
   XglgGetSResource( message_obj, "Format", &format );
   XglgGetSResource( message_obj, "Action", &action );
   XglgGetSResource( message_obj, "Origin", &origin );

   /* Handle window closing. May use viewport's name. */
   if( strcmp( format, "Window" ) == 0 &&
      strcmp( action, "DeleteWindow" ) == 0 )
     exit( 0 );

   /* Do not do anything if the message did not come from a button or
    * action is different from Activate.
    */
   if( strcmp( format, "Button" ) != 0  ||
      strcmp( action, "Activate" ) != 0 )
     return;

   /* Act based on the selected button. */
   if( strcmp( origin , "Faster" ) == 0 )
   {
      /* Increase animation speed */
      if( TimeInterval > 1 )
        TimeInterval /= 2;
   }
   else if( strcmp( origin , "Slower" ) == 0 )
   {
      /* Decrease animation speed */
      if( TimeInterval < 5000 )
        TimeInterval *= 2;
   }
}

/*----------------------------------------------------------------------
| Simulation: calculates the new position of the ball.
*/
void GetNewPosition( x_pos, y_pos )
     double
       * x_pos,
       * y_pos;
{
   static double     /* Change in range 0-2*PI */
     x_value = 0.,
     y_value = 0.;    
   double
     x_center,
     y_center,
     x_amplitude,
     y_amplitude;
   
   /* Increase x value counter */
   x_value += XIncrement;
   if( x_value > 2. * M_PI )
     x_value -= 2. * M_PI;

   /* Increase y value counter */
   y_value += YIncrement;
   if( y_value > 2. * M_PI )
     y_value -= 2. * M_PI;

   /* Find the center of the ball's movement area */
   x_center = ( XMax + XMin ) / 2.;
   y_center = ( YMax + YMin ) / 2.;

   /* The extent of the ball's movements */
   x_amplitude = ( XMax - XMin ) / 2. - Radius;
   y_amplitude = ( YMax - YMin ) / 2. - Radius;
   
   /* Calculate the ball's current position */
   *x_pos = x_center + x_amplitude * sin( x_value );
   *y_pos = y_center + y_amplitude * cos( y_value );
}
