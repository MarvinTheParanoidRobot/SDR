/*----------------------------------------------------------------------
| This example demonstrates how to load a GLG drawing and update
| its dynamic attributes periodically, as well as handle object
| selection with the mouse. The program exits when user clicks 
| on a moving object.
|
| Periodic dynamic updates are handled in the Update procedure, which
| is invoked when a specified time interval elapses. It is registered
| as a Timer procedure using GlgAddTimeOut function with a specified
| time interval.
|
| Object selection event is handled in the Select callback.
|
| The "animation.g" drawing contains a ball named "CatchMe" and a polygon
| named "Area". The lower left and upper right control points of the area
| polygon are named "LLPoint" and "URPoint". The program queries the 
| coordinates of these control points and uses them to animate the ball
| by moving it inside the area. The ball has X and Y move transformations
| attached to it to control its position. The program sets the XValue 
| and YValue parameters of the transformations to move the ball.
*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "GlgClass.h"

// Set this defined constant to be 1 to use code generated by the
// GLG Code Generation Utility. Save the drawing uncompressed to 
// generate code.
//
#define USE_GENERATED_CODE     0

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950
#endif

#define DELTA     ( 2. * M_PI / 500. )

// Global animation parameters.
double XIncrement = DELTA * 8.;
double YIncrement = DELTA * 7.;
double Radius;                   // Moving ball's radius
double XMin, XMax, YMin, YMax;   // Ball movement area   

// Time interval for periodic dynamic updates, in millisec.
GlgLong TimeInterval = 20; 

GlgAppContext AppContext;

class AnimationExample : public GlgObjectC
{
 public:

   AnimationExample( void );
   virtual ~AnimationExample( void );

   // Override to supply custom Input and Selection methods
   void Input( GlgObjectC& callback_viewport, GlgObjectC& message );
   void Select( GlgObjectC& callback_viewport, CONST char ** name_array );
};

// Function prototypes
extern "C" void Update( AnimationExample*, GlgLong* );
void GetNewPosition( double *x_pos, double *y_pos );

#if USE_GENERATED_CODE
// The following symbols should be defined in the file generated by the
// GLG Code Generation Utility.
//
extern long AnimationData[];
extern long AnimationDataSize;
#endif

// Defines a platform-specific program entry point.
#include "GlgMain.h"

/////////////////////////////////////////////////////////////////////////////
// Main Entry point.
/////////////////////////////////////////////////////////////////////////////
int GlgMain( int argc, char *argv[], GlgAppContext InitAppContext )
{
   GlgSessionC glg_session( False, InitAppContext, argc, argv );
   AnimationExample animation;
   double z;

   AppContext = glg_session.GetAppContext();

   // Create a GLG object either from a file or a generated image.
#if USE_GENERATED_CODE
   // Use a generated drawing image.
   animation.LoadWidget( AnimationData, AnimationDataSize );
#else
   // Take the drawing from a file.
   animation.LoadWidget( "animation.g" );
#endif
   
   // Query the ball's radius.
   animation.GetResource( "CatchMe/Radius", &Radius );

   // Query the extent of the ball's movement area.
   animation.GetResource( "Area/LLPoint", &XMin, &YMin, &z );
   animation.GetResource( "Area/URPoint", &XMax, &YMax, &z );

   // Set widget dimensions using world coordinates [-1000;1000].
   // If not set, default dimensions will be used as set in the GLG editor.
   animation.SetResource( "Point1", -600., -700., 0. );
   animation.SetResource( "Point2", 600., 700., 0. );

   // Enable input and selection callbacks
   animation.EnableCallback( GLG_INPUT_CB );
   animation.EnableCallback( GLG_SELECT_CB );
      
   animation.InitialDraw();

   // Add a timer to periodically update the drawing
   GlgAddTimeOut( AppContext, TimeInterval, (GlgTimerProc)Update, 
		  (GlgAnyType)&animation );

   return (int) GlgMainLoop( AppContext );
}

/////////////////////////////////////////////////////////////////////////////
// Animates the ball by moving it inside the area defined in the drawing.
/////////////////////////////////////////////////////////////////////////////
extern "C" void Update( AnimationExample * animation, GlgLong *timer_id )
{
   double x_pos, y_pos;     

   // Calculate new coordinates of the ball.
   GetNewPosition( &x_pos, &y_pos );

   // Set coordinates of the ball in the drawing.
   animation->SetResource( "CatchMe/XValue", x_pos );
   animation->SetResource( "CatchMe/YValue", y_pos );

   animation->Update();    // Makes changes visible.
   animation->Sync();      // Improves interactive response.

   // Reinstall the timer to continue updating.
   GlgAddTimeOut( AppContext, TimeInterval, (GlgTimerProc)Update, 
		  (GlgAnyType)animation );
}

/////////////////////////////////////////////////////////////////////////////
// This callback is invoked when user selects some object in the drawing
// with the mouse. In this program, it's used to exit animation if
// user selects the moving object, which is named "CatchMe".
/////////////////////////////////////////////////////////////////////////////
void AnimationExample::Select( GlgObjectC& viewport, CONST char ** name_array )
{
   CONST char * name;
   int i, j;

   if( name_array )    // Something was selected.
   {
      for( i=0; name = name_array[ i ]; ++i )
	if( strcmp( name, "Faster" ) == 0 || strcmp( name, "Slower" ) == 0 )
	  // Ignore buttons selection
	  return;   

      for( i=0; name = name_array[ i ]; ++i )
	if( strcmp( name, "CatchMe" ) == 0 )
	{
	   // Got the moving object: blink three times and exit.
	   for( j=0; j<6; ++j )
	   {
	      // Change the index of the color dynamics attached to the
	      // object's FillColor attribute from 0 to 1 and back to blink.
	      // You can check it in the editor by selecting the FillColor 
	      // attribute of the object and clicking on the Edit Dynamics 
	      // button in the Attribute Dialog.
		
	      SetResource( "CatchMe/ColorIndex", ( j % 2 ) ? 1. : 0. );
	      Update();
	      GlgSleep( 100 );   // Delay for 0.1 sec
	   }
	   exit( 0 );
	}
   }
	  
   GlgBell( viewport );   // Missed: beep'em up!
}

/////////////////////////////////////////////////////////////////////////////
// This callback is invoked when user interacts with input objects in GLG
// drawing. In this program, it is used to increase or decrease the animation
// speed.
/////////////////////////////////////////////////////////////////////////////
void AnimationExample::Input( GlgObjectC& viewport, GlgObjectC& message )
{
   CONST char
     * format,
     * action,
     * origin;
      
   // Get the message's format, action and origin.
   message.GetResource( "Format", &format );
   message.GetResource( "Action", &action );
   message.GetResource( "Origin", &origin );

   // Handle window closing. May use viewport's name.
   if( strcmp( format, "Window" ) == 0 &&
      strcmp( action, "DeleteWindow" ) == 0 )
     exit( 0 );

   // Do not do anything if the message did not come from a button or
   // action is different from Activate.
   //
   if( strcmp( format, "Button" ) != 0  ||
      strcmp( action, "Activate" ) != 0 )
     return;

   // Act based on the selected button.
   if( strcmp( origin , "Faster" ) == 0 )
   {
      // Increase animation speed
      if( TimeInterval > 1 )
        TimeInterval /= 2;
   }
   else if( strcmp( origin , "Slower" ) == 0 )
   {
      // Decrease animation speed
      if( TimeInterval < 5000 )
        TimeInterval *= 2;
   }
}

AnimationExample::AnimationExample( void )
{
}

AnimationExample::~AnimationExample( void )
{
}

/////////////////////////////////////////////////////////////////////////////
// Simulation: calculates the new position of the ball.
/////////////////////////////////////////////////////////////////////////////
void GetNewPosition( double * x_pos, double * y_pos )
{
   static double     /* Change in range 0-2*PI */
     x_value = 0.,
     y_value = 0.;    
   double
     x_center,
     y_center,
     x_amplitude,
     y_amplitude;
   
   /* Increase x value counter */
   x_value += XIncrement;
   if( x_value > 2. * M_PI )
     x_value -= 2. * M_PI;

   /* Increase y value counter */
   y_value += YIncrement;
   if( y_value > 2. * M_PI )
     y_value -= 2. * M_PI;

   /* Find the center of the ball's movement area */
   x_center = ( XMax + XMin ) / 2.;
   y_center = ( YMax + YMin ) / 2.;

   /* The extent of the ball's movements */
   x_amplitude = ( XMax - XMin ) / 2. - Radius;
   y_amplitude = ( YMax - YMin ) / 2. - Radius;
   
   /* Calculate the ball's current position */
   *x_pos = x_center + x_amplitude * sin( x_value );
   *y_pos = y_center + y_amplitude * cos( y_value );
}
