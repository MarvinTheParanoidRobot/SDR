#include <stdio.h>
#include <stdlib.h> 
#include "GlgApi.h"

/* Set this defined constant to be 1 to use code generated by the
 * GLG Code Generation Utility. Save the drawing uncompressed to 
 * generate code.
 */
#define USE_GENERATED_CODE     0

/* Function prototypes */
void Input( GlgObject viewport, GlgAnyType client_data, GlgAnyType call_data );
void UpdateGraph( GlgObject viewport, GlgLong *timer_id );
double GetData( void );

#if USE_GENERATED_CODE
/* The following symbols should be defined in the file generated by the
 * GLG Code Generation Utility.
 */
extern long GraphData[];
extern long GraphDataSize;
#endif

/* Time interval for periodic dynamic updates, in millisec. */
GlgLong TimeInterval = 500; 
GlgAppContext AppContext;

/* Defines a platform-specific program entry point */
#include "GlgMain.h"

/*-------------------------------------------------------------------------
|
| This program illustrates using most of the GLG Widget's features with
| GLG generic API. The program creates a GLG widget with a bar graph in it
| and fills it with random data, using resources to change graph's
| attributes. 
| 
| The widget's Input callback is used to handle the user feedback
| via the use of a Custom MouseClickEvent added to the DataSample
| object in the Builder.
|
| When a user selects a particular bar (DataSample) with the
| mouse, the DataSample's name and value get displayed in a 
| text object.
|
| In order to use this program template with a diffrent drawing file,
| replace "bar_graph.g" with the name of your drawing file and adust resource
| names.
*/
int GlgMain( argc, argv, InitAppContext )
     int argc;
     char *argv[];
     GlgAppContext InitAppContext;
{
 
   GlgObject viewport;

   AppContext = GlgInit( False, InitAppContext, argc, argv );

#if USE_GENERATED_CODE   
   /* Use a generated drawing image. */
   viewport = GlgLoadWidgetFromImage( (char*)GraphData, GraphDataSize );
#else
   /* Take a drawing from the file. */
   viewport = GlgLoadWidgetFromFile( "bar_graph.g" );
#endif
   if( !viewport )
     exit( 1 );
   
   /* Setting widget dimensions using world coordinates [-1000;1000].
      If not set, default dimensions will be used as set in the GLG editor.
      */
   GlgSetGResource( viewport, "Point1", -500., -500., 0. );
   GlgSetGResource( viewport, "Point2", 400., 400., 0. );

   /* Setting the window name (title). */
   GlgSetSResource( viewport, "ScreenName", "GlgExample" );

   /* Set some optional resources for the initial appearance of the widget.
    * To avoid setting these resources every time on start up, use the
    * Editor to save the customized version of the widget with the desired
    * values of resources.
    */

   /* Set the background color of the widget to be white. */
   GlgSetGResource( viewport, "FillColor", 1., 1., 1. );
   
   /* Set the number of datasamples in the graph to 30. */
   GlgSetDResource( viewport, "DataGroup/Factor", 30. );

   /* Set the number of X labels and minor ticks */
   GlgSetDResource( viewport, "XLabelGroup/Factor", 6. );
   GlgSetDResource( viewport, "XLabelGroup/MinorFactor", 5. );
   
   /* Set the initial value of all bars to be 0 on the initial appearance. */
   GlgSetDResource( viewport, "DataGroup/DataSample/Value", 0. );
   
   /* Set all labels to display empty strings on the initial appearance. */
   GlgSetSResource( viewport, "XLabelGroup/XLabel/String", "" );

   /* Set the fill color of all bars of a bar graph to be green by
    * setting the color of a template datasample.
    */
   GlgSetGResource( viewport, "DataGroup/DataSample/FillColor", 0., 1., 0. );
   
   /* Setting datasample's color attribute to be local to allow independent
    * color change of individial datasamples.
    */
   GlgSetDResource( viewport, "DataGroup/DataSample/FillColor/Global", 0. );

   /* Make  the SelectedBarLabel object invisible.*/
   GlgSetDResource( viewport, "SelectedBarLabel/Visibility", 0.0 );

   /* Add input callback for handling user feedback */
   GlgAddCallback( viewport, GLG_INPUT_CB, (GlgCallbackProc)Input, NULL );
   
   GlgSetupHierarchy( viewport );   /* Creates the hierarchy */

   /* The following resources may be accessed only after the hierarchy has
      been created.
      */

   /* Set the color of the second bar to be blue. */
   GlgSetGResource( viewport, "DataGroup/DataSample2/FillColor", 0., 0., 1. );
   
   /* Push the first value and the first label, so that the graph displays
    * one data value on the initial appearance.
    * GetData function is used to supply data for the graph.
    * Labels in this example are labeled sequentially starting with "1".
    */
   GlgSetDResource( viewport, "DataGroup/EntryPoint", GetData() );
   GlgSetSResource( viewport, "XLabelGroup/EntryPoint", "Value 1" );

   /* Store the label in a datasample as well to display it when 
      the datasample is selected. The stock graph was moditied to add 
      this additional entry point. */
   GlgSetSResource( viewport, "DataGroup/SampleNameEntryPoint", "Value 1" );

   GlgUpdate( viewport );

   /* Add a timer procedure to update the graph. */
   GlgAddTimeOut( AppContext, TimeInterval, 
		  (GlgTimerProc)UpdateGraph, (GlgAnyType)viewport );
   
   return (int) GlgMainLoop( AppContext );
}

/*----------------------------------------------------------------------
| Pushes the next data and label values and updates the graph.
*/
void UpdateGraph( viewport, timer_id )
     GlgObject viewport;
     GlgLong * timer_id;
{
   static long iteration_counter = 2; /* A counter used to generate labels. */
   char * label;

   /* Push the next data value, let the graph handle scrolling. */
   GlgSetDResource( viewport, "DataGroup/EntryPoint", GetData() );

   /* Generate the next label to use. */
   label = GlgCreateIndexedName( "Value ", iteration_counter );
   ++iteration_counter;

   /* Push the next label. The graph handles labels scrolling.
    * To set labels directly, use "XLabelGroup/Xlabel<n>/String" as a
    * name of a resource, where <n> is the sequential zero-based label
    * index. In this case you will be responsible for handling label
    * scrolling.
    */
   GlgSetSResource( viewport, "XLabelGroup/EntryPoint", label );

   /* Store the label in a datasample as well to display it when 
      the datasample is selected. The stock graph was moditied to add 
      this additional entry point. */
   GlgSetSResource( viewport, "DataGroup/SampleNameEntryPoint", label );

   GlgFree( label );        /* Free the label. */

   GlgUpdate( viewport );   /* Makes changes visible. */

   /* Reinstall the timeout to continue updating */
   GlgAddTimeOut( AppContext, TimeInterval, 
				(GlgTimerProc)UpdateGraph,
				(GlgAnyType)viewport );
}

/*----------------------------------------------------------------------
| Returns a random number in the [0;1] range. Use a real source of data
| instead of this function.
*/
double GetData()
{
   return GlgRand( 0., 1. );
}


/*----------------------------------------------------------------------
| In this example, Input callback is used to process Custom MouseClick 
| events for the DataSamples. When the user selects a DataSample with 
| the mouse, its value will be displayed in the text object named 
| SelectedBarLabel.
*/
void Input( viewport, client_data, call_data )
     GlgObject viewport;
     GlgAnyType client_data;
     GlgAnyType call_data;
{
   GlgObject message_obj;
   double bar_value;
   char
      * format,
      * action,
      * event_label,
      * sample_name;

   message_obj = (GlgObject) call_data;

   /* Get the message's format and action. */
   GlgGetSResource( message_obj, "Format", &format );
   GlgGetSResource( message_obj, "Action", &action );

   /* Handle window closing. May use viewport's name. */
   if( strcmp( format, "Window" ) == 0 &&
      strcmp( action, "DeleteWindow" ) == 0 )
     exit( 0 );

   if( strcmp( format, "CustomEvent" ) == 0 &&
      strcmp( action, "MouseClick" ) == 0 )
   {
      GlgGetSResource( message_obj,  "EventLabel", &event_label );
      if( strcmp( event_label, "BarSelected" ) == 0 ) /* Bar selected */
      {
	 /* The DataSample was selected. Retrieve its value and sample name.
            The stock graph was modified by adding a SampleName custom propery
            to the graph's datasample. If a stock graph is used, use the 
            Object/Name resource instead of Object/SampleName to retrieve 
            the name of the datasample object instead of the stored label.
            */
	 GlgGetDResource( message_obj, "Object/Value", &bar_value );
	 GlgGetSResource( message_obj, "Object/SampleName", &sample_name );
	    
	 /* Display the bar name and value in a text object 
	    named "SelectedBarLabel". */
	 GlgSetDResource( viewport, 
			  "SelectedBarLabel/DataSampleValue", bar_value );
	 GlgSetSResource( viewport, 
			  "SelectedBarLabel/DataSampleName", sample_name );
	 GlgSetDResource( viewport, "SelectedBarLabel/Visibility", 1.0 );
      }
   }
   GlgUpdate( viewport );
}
