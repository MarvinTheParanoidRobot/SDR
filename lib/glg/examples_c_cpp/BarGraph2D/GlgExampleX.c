#include <stdio.h>
#include <stdlib.h> 

/* Set this defined constant to 1 to use motif. */
#define USE_MOTIF              0

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#if USE_MOTIF
#include <Xm/Form.h>
#endif

#include "GlgWrapper.h"

/* Set this defined constant to be 1 to use code generated by the
 * GLG Code Generation Utility. Save the drawing uncompressed to 
 * generate code.
 */
#define USE_GENERATED_CODE     0

#define WIDTH     800
#define HEIGHT    600

/* Function prototypes */
void NumInit( Widget widget, XtPointer client_data, XtPointer call_data );
void ValInit( Widget widget, XtPointer client_data, XtPointer call_data );
void Input( Widget widget, XtPointer client_data, XtPointer call_data );
void UpdateGraph( Widget widget, XtIntervalId *timer_id  );
double GetData( void );

/* Time interval for periodic dynamic updates, in millisec. */
unsigned int TimeInterval = 500; 
XtAppContext AppContext;

#if USE_GENERATED_CODE
/* The following symbols should be defined in the file generated by the
 * GLG Code Generation Utility.
 */
extern long GraphData[];
extern long GraphDataSize;
#endif

/*-------------------------------------------------------------------------
|
| This program illustrates using most of the GLG Widget's features with
| X Windows API. The program creates a GLG widget with a bar graph in it
| and fills it with random data, using resources to change graph's
| attributes. 
| 
| The widget's Input callback is used to handle the user feedback
| via the use of a Custom MouseClickEvent added to the DataSample
| object in the Builder.
|
| When a user selects a particular bar (DataSample) with the
| mouse, the DataSample's name and value get displayed in a 
| text object.
|
| In order to use this program template with a diffrent drawing file,
| replace "bar_graph.g" with the name of your drawing file and adust resource
| names.
*/

int main( int argc, char *argv[] )
{
   Display * display;
   Widget shell, form, glgWrapper;
   GlgObject viewport;
   Cardinal ac;
   Arg al[20];
   
   /* Initialize X Toolkit and create an application context. */
   XtToolkitInitialize();
   AppContext = XtCreateApplicationContext();
   
   /* Open a display connection. */
   display =
     XtOpenDisplay( AppContext, NULL, "GlgExample", "Glg", 0, 0, &argc, argv );
   
   /* Create a shell */
   ac = 0;
   XtSetArg( al[ac], XtNbaseWidth, WIDTH ); ac++;
   XtSetArg( al[ac], XtNbaseHeight, HEIGHT ); ac++;
   XtSetArg( al[ac], XtNwidth, WIDTH ); ac++;
   XtSetArg( al[ac], XtNheight, HEIGHT ); ac++;
   XtSetArg( al[ac], XtNminWidth, 10 ); ac++;
   XtSetArg( al[ac], XtNminHeight, 10 ); ac++;
   XtSetArg( al[ac], XtNallowShellResize, True ); ac++;
   XtSetArg( al[ac], XtNinput, TRUE ); ac++;
   shell =
     XtAppCreateShell( "GlgExample", "Glg", applicationShellWidgetClass,
		      display, al, ac );
   
#if USE_MOTIF
   /* Create a motif form widget to hold the GlgWrappper widget. */
   ac = 0;
   XtSetArg( al[ac], XmNresizable, TRUE ); ac++;
   form = XmCreateForm( shell, "form", al, ac );
   XtManageChild( form );
#else
   /* If not using motif, attach the GlgWrapper directly to the shell. */
   form = shell;
#endif

   /* Create a GLG widget. */
   ac = 0;
   
   /* Specify a drawing to use, either from a file or a generated image. */
#if USE_GENERATED_CODE
   /* Use a generated drawing image. */
   XtSetArg( al[ac], XtNglgDrawingImage, GraphData ); ac++;
   XtSetArg( al[ac], XtNglgImageSize, GraphDataSize ); ac++;
#else
   /* Take a drawing from the file. */
   XtSetArg( al[ac], XtNglgDrawingFile, "bar_graph.g" ); ac++;
#endif
   
   /* Set some optional resources for the initial appearance of the widget.
    * To avoid setting these resources every time on start up, use the
    * Editor to save the customized version of the widget with the desired
    * values of resources.
    */
   /* Set the background color of the widget. */
   XtSetArg( al[ac], XtNglgVResource0, "FillColor g 1. 1. 1." ); ac++;
   
   /* Set the number of datasamples in the graph to 30. */
   XtSetArg( al[ac], XtNglgHResource0, "DataGroup/Factor d 30" ); ac++;
   
   /* Set the number of X labels and minor ticks */
   XtSetArg( al[ac], XtNglgHResource1, "XLabelGroup/Factor d 6" ); ac++;
   XtSetArg( al[ac], XtNglgHResource2, "XLabelGroup/MinorFactor d 5" ); ac++;
   
   /* Set the initial value of all bars to be 0 on the initial appearance. */
   XtSetArg( al[ac], XtNglgHResource3,
	    "DataGroup/DataSample/Value d 0." ); ac++;
   
   /* Set all labels to display empty strings on the initial appearance. */
   XtSetArg( al[ac], XtNglgHResource4, "XLabelGroup/XLabel/String s" ); ac++;

   /* Set the fill color of all bars of a bar graph to be green by
    * setting the color of a template datasample.
    */
   XtSetArg( al[ac], XtNglgHResource5,
	    "DataGroup/DataSample/FillColor g 0. 1. 0." ); ac++;

   /* Setting datasample's color attribute to be local to allow independent
    * color change of individial datasamples.
    */
   XtSetArg( al[ac], XtNglgHResource6,
	     "DataGroup/DataSample/FillColor/Global d 0." ); ac++;

   /* Make  the SelectedBarLabel object invisible.*/
   XtSetArg( al[ac], XtNglgHResource7,
	     "SelectedBarLabel/Visibility d 0." ); ac++;
   
#if USE_MOTIF
   /* If using motif, attach the GlgWrapper to a form. */
   XtSetArg( al[ac], XmNleftAttachment, XmATTACH_FORM ); ac++;
   XtSetArg( al[ac], XmNrightAttachment, XmATTACH_FORM ); ac++;
   XtSetArg( al[ac], XmNtopAttachment, XmATTACH_FORM ); ac++;
   XtSetArg( al[ac], XmNbottomAttachment, XmATTACH_FORM ); ac++;
#endif
   
   /* Create an instance of a GLG Wrapper widget. */
   glgWrapper =
     XtCreateWidget( "GlgWrapper", glgWrapperWidgetClass, form, al, ac );
   
   /* Add initialization and selection callbacks, if any. */
   XtAddCallback( glgWrapper, XtNglgNumInitCB, NumInit, NULL );
   XtAddCallback( glgWrapper, XtNglgValInitCB, ValInit, NULL );

   /* Add input callback for handling user feedback */
   XtAddCallback( glgWrapper, XtNglgInputCB, Input, NULL );
   
   XtManageChild( glgWrapper ); 
   
   XtRealizeWidget( shell );
   
   /* Add a timer procedure to update the graph. */
   XtAppAddTimeOut( AppContext, TimeInterval,
		    (XtTimerCallbackProc)UpdateGraph, (XtPointer)glgWrapper );
   
   XtAppMainLoop( AppContext );
}

/*-----------------------------------------------------------------------
| This callback is called after creating the widget's viewport but before
| creating the drawing hierarchy in the viewport.
| It may be used to set the number of objects in the hierarchy.
*/
void NumInit( widget, client_data, call_data )
     Widget widget;
     XtPointer client_data;
     XtPointer call_data;
{
   GlgObject viewport;
   
   viewport = XglgGetWidgetViewport( widget );
   
   /* Set the number of datasamples in the graph to be 30. This is redundant,
    * since it is done already via resources when the widget was created.
    * It is repeated here only for the sake of an example. 
    */
   XglgSetDResource( viewport, "DataGroup/Factor", 30. );
}

/*----------------------------------------------------------------------
| This callback is called after creating the drawing hierarchy but before
| drawing it. Since the hierarchy has been created already, individual
| elements of it may be accessed.
*/
void ValInit( widget, client_data, call_data )
     Widget widget;
     XtPointer client_data;
     XtPointer call_data;
{
   GlgObject viewport;

   viewport = XglgGetWidgetViewport( widget );
   
   /* All resources may be set when the widget is created;
    * doing it here only for the sake of an example.
    */

   /* Set the color of the second bar to be blue. */
   XglgSetGResource( viewport, "DataGroup/DataSample2/FillColor", 0., 0., 1. );
   
   /* Push the first value and the first label, so that the graph displays
    * one data value on the initial appearance.
    * GetData function is used to supply data for the graph.
    * Labels in this example are labeled sequentially starting with "1".
    */
   XglgSetDResource( viewport, "DataGroup/EntryPoint", GetData() );
   XglgSetSResource( viewport, "XLabelGroup/EntryPoint", "Value 1" );

   /* Store the label in a datasample as well to display it when 
      the datasample is selected. The stock graph was moditied to add 
      this additional entry point. */
   XglgSetSResource( viewport, "DataGroup/SampleNameEntryPoint", "Value 1" );
}

/*----------------------------------------------------------------------
| Pushes the next data and label values and updates the graph.
*/
void UpdateGraph( widget, timer_id )
     Widget widget;
     XtIntervalId *timer_id;
{
   static long iteration_counter = 2; /* A counter used to generate labels. */
   GlgObject viewport;
   char * label;

   viewport = XglgGetWidgetViewport( widget );

   /* Push the next data value, let the graph handle scrolling. */
   XglgSetDResource( viewport, "DataGroup/EntryPoint", GetData() );

   /* Generate the next label to use. */
   label = XglgCreateIndexedName( "Value ", iteration_counter );
   ++iteration_counter;

   /* Push the next label. The graph handles labels scrolling.
    * To set labels directly, use "XLabelGroup/Xlabel<n>/String" as a
    * name of a resource, where <n> is the sequential zero-based label
    * index. In this case you will be responsible for handling label
    * scrolling.
    */
   XglgSetSResource( viewport, "XLabelGroup/EntryPoint", label );

   /* Store the label in a datasample as well to display it when 
      the datasample is selected. The stock graph was moditied to add 
      this additional entry point. */
   XglgSetSResource( viewport, "DataGroup/SampleNameEntryPoint", label );

   XglgFree( label );     /* Free the label. */

   XglgUpdate( viewport );                 /* Makes changes visible. */

   /* Reinstall the timeout to continue updating */
   XtAppAddTimeOut( AppContext, TimeInterval,
		    (XtTimerCallbackProc)UpdateGraph, (XtPointer)widget );
}

/*----------------------------------------------------------------------
| Returns a random number in the [0;1] range. Use a real source of data
| instead of this function.
*/
double GetData()
{
   return GlgRand( 0., 1. );
}

/*----------------------------------------------------------------------
| In this example, Input callback is used to process Custom MouseClick 
| events for the DataSamples. When the user selects a DataSample with 
| the mouse, its value will be displayed in the text object named 
| SelectedBarLabel.
*/
void Input( widget, client_data, call_data )
     Widget widget;
     XtPointer client_data;
     XtPointer call_data;
{
   GlgObject
     message_obj,
     viewport;

   double bar_value;
   char
      * format,
      * action,
      * event_label,
      * sample_name;

   message_obj = (GlgObject) call_data;
   viewport = XglgGetWidgetViewport( widget );

   /* Get the message's format and action. */
   XglgGetSResource( message_obj, "Format", &format );
   XglgGetSResource( message_obj, "Action", &action );

   /* Handle window closing. May use viewport's name. */
   if( strcmp( format, "Window" ) == 0 &&
      strcmp( action, "DeleteWindow" ) == 0 )
     exit( 0 );

   if( strcmp( format, "CustomEvent" ) == 0 &&
      strcmp( action, "MouseClick" ) == 0 )
   {
      XglgGetSResource( message_obj,  "EventLabel", &event_label );
      if( strcmp( event_label, "BarSelected" ) == 0 ) /* Bar selected */
      {
	 /* The DataSample was selected. Retrieve its value and sample name.
            The stock graph was modified by adding a SampleName custom propery
            to the graph's datasample. If a stock graph is used, use the 
            Object/Name resource instead of Object/SampleName to retrieve 
            the name of the datasample object instead of the stored label. 
            */
         XglgGetDResource( message_obj, "Object/Value", &bar_value );
         XglgGetSResource( message_obj, "Object/SampleName", &sample_name );
	    
         /* Display the bar name and value in a text object 
            named "SelectedBarLabel". */
         XglgSetDResource( viewport, 
                          "SelectedBarLabel/DataSampleValue", bar_value );
         XglgSetSResource( viewport, 
                          "SelectedBarLabel/DataSampleName", sample_name );
         XglgSetDResource( viewport, "SelectedBarLabel/Visibility", 1.0 );
      }
   }
   XglgUpdate( viewport );
}
